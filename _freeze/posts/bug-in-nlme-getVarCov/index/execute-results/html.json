{
  "hash": "54c24baafbc6a8dd9dd1ed5f235e687f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Bug in nlme::getVarCov\ndate: '2016-08-10'\ncategories:\n- Rstats\n- programming\n- hierarchical models\n- nlme\ncode-tools: true\n---\n\n\n::: {.callout-note}\nThe bug documented here was present in version 3.1-129 of `nlme`. In porting my website to Quarto, I have been unable to figure out how to install an archival version of the package, so the post is compiled under version 3.1-165 on R 4.3.3. The bug was subsequently fixed, so the following won't make much sense. \n:::\n\nI have recently been working to ensure that [my `clubSandwich` package](https://github.com/jepusto/clubSandwich) works correctly on fitted `lme` and `gls` models from the `nlme` package, which is one of the main R packages for fitting hierarchical linear models. In the course of digging around in the guts of `nlme`, I noticed a bug in the `getVarCov` function, in version 3.1-129. The purpose of the function is to extract the estimated variance-covariance matrix of the errors from a fitted `lme` or `gls` model. \n\nIt seems that this function is sensitive to the order in which the input data are sorted. [This bug report](https://bugs.r-project.org/bugzilla3/show_bug.cgi?id=16744) noted the problem, but unfortunately their proposed fix doesn't seem to solve the problem. In this post I'll demonstrate the bug and a solution. (I'm posting this here because the R project's bug reporting system is currently closed to people who were not registered as of early July, evidently due to some sort of spamming problem.)\n\n# The issue\n\nHere's a simple demonstration of the problem. I'll first fit a `gls` model with a heteroskedastic variance function and an AR(1) auto-correlation structure (no need to worry about the substance of the specification---we're just worried about computation here) and then extract the variances for each of the units.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Demonstrate the problem with gls model\n\nlibrary(nlme)\ndata(Ovary)\n\ngls_raw <- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), data = Ovary,\n               correlation = corAR1(form = ~ 1 | Mare),\n               weights = varPower())\n\nMares <- levels(gls_raw$groups)\nV_raw <- lapply(Mares, function(g) getVarCov(gls_raw, individual = g))\n```\n:::\n\n\nNow I'll repeat the process using the same data, but sorted in a different order\n\n::: {.cell}\n\n```{.r .cell-code}\nOvary_sorted <- Ovary[with(Ovary, order(Mare, Time)),]\ngls_sorted <- update(gls_raw, data = Ovary_sorted)\n\nV_sorted <- lapply(Mares, function(g) getVarCov(gls_sorted, individual = g))\n```\n:::\n\n\nThe variance component estimates are essentially equal:\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(gls_raw$modelStruct, gls_sorted$modelStruct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nHowever, the extracted variance-covariance matrices are not:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(V_raw, V_sorted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\nHere's the code of the relevant function:\n\n::: {.cell}\n\n```{.r .cell-code}\nnlme:::getVarCov.gls\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (obj, individual = 1, ...) \n{\n    if (is.null(csT <- obj$modelStruct$corStruct)) \n        stop(\"not implemented for uncorrelated errors\")\n    if (is.null(grp <- getGroups(csT))) \n        stop(\"not implemented for correlation structures without a grouping factor\")\n    ind <- if (is.numeric(individual)) {\n        as.integer(grp) == individual\n    }\n    else grp == individual\n    ni <- sum(ind, na.rm = TRUE)\n    if (ni == 0) \n        stop(gettextf(\"individual %s was not used in the fit\", \n            sQuote(individual)), domain = NA)\n    S <- if (ni > 1) \n        corMatrix(csT)[[individual]]\n    else diag(1)\n    if (!is.null(obj$modelStruct$varStruct)) {\n        vw <- 1/varWeights(obj$modelStruct$varStruct)[ind]\n    }\n    else vw <- rep(1, ni)\n    vars <- (obj$sigma * vw)^2\n    result <- t(S * sqrt(vars)) * sqrt(vars)\n    class(result) <- c(\"marginal\", \"VarCov\")\n    attr(result, \"group.levels\") <- names(obj$groups)\n    result\n}\n<bytecode: 0x000001b73ebde7a0>\n<environment: namespace:nlme>\n```\n\n\n:::\n:::\n\n\nThe issue is in the 4th line of the body. `getVarCov.gls` assumes that `varWeights(obj$modelStruct$varStruct)` is sorted in the same order as `obj$groups`, which is not necessarily true. Instead, `varWeights` seem to return the weights sorted according to the grouping variable. For this example, that means that the `varWeights` will not depend on the order in which the groups are sorted.\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(gls_raw$groups, gls_sorted$groups)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nidentical(varWeights(gls_raw$modelStruct$varStruct), \n          varWeights(gls_sorted$modelStruct$varStruct))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n# Fix for `nlme:::getVarCov.gls`\n\nI think this can be solved by either \n\n* putting the `varWeights` back into the same order as the raw data or\n* sorting `obj$groups` before identifying the rows corresponding to the specified `individual`. \n\nHere's a revised function that takes the second approach:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# proposed patch for getVarCov.gls\n\ngetVarCov_revised_gls <- function (obj, individual = 1, ...) {\n    S <- corMatrix(obj$modelStruct$corStruct)[[individual]]\n    if (!is.null(obj$modelStruct$varStruct)) {\n        ind <- sort(obj$groups) == individual\n        vw <- 1 / varWeights(obj$modelStruct$varStruct)[ind]\n    }\n    else vw <- rep(1, nrow(S))\n    vars <- (obj$sigma * vw)^2\n    result <- t(S * sqrt(vars)) * sqrt(vars)\n    class(result) <- c(\"marginal\", \"VarCov\")\n    attr(result, \"group.levels\") <- names(obj$groups)\n    result\n}\n```\n:::\n\n\nTesting that it works correctly:\n\n::: {.cell}\n\n```{.r .cell-code}\nV_raw <- lapply(Mares, function(g) getVarCov_revised_gls(gls_raw, individual = g))\nV_sorted <- lapply(Mares, function(g) getVarCov_revised_gls(gls_sorted, individual = g))\nall.equal(V_raw, V_sorted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n# Fix for `nlme:::getVarCov.lme`\n\nThe same issue comes up in `getVarCov.lme`. Here's the fix and verification:\n\n::: {.cell}\n\n```{.r .cell-code}\n# proposed patch for getVarCov.lme\n\ngetVarCov_revised_lme <- function (obj, individuals, type = c(\"random.effects\", \"conditional\", \"marginal\"), ...) {\n    type <- match.arg(type)\n    if (any(\"nlme\" == class(obj))) \n        stop(\"not implemented for \\\"nlme\\\" objects\")\n    if (length(obj$group) > 1) \n        stop(\"not implemented for multiple levels of nesting\")\n    sigma <- obj$sigma\n    D <- as.matrix(obj$modelStruct$reStruct[[1]]) * sigma^2\n    if (type == \"random.effects\") {\n        result <- D\n    }\n    else {\n        result <- list()\n        groups <- sort(obj$groups[[1]])\n        ugroups <- unique(groups)\n        if (missing(individuals)) \n            individuals <- as.matrix(ugroups)[1, ]\n        if (is.numeric(individuals)) \n            individuals <- ugroups[individuals]\n        for (individ in individuals) {\n            indx <- which(individ == ugroups)\n            if (!length(indx)) \n                stop(gettextf(\"individual %s was not used in the fit\", \n                  sQuote(individ)), domain = NA)\n            if (is.na(indx)) \n                stop(gettextf(\"individual %s was not used in the fit\", \n                  sQuote(individ)), domain = NA)\n            ind <- groups == individ\n            if (!is.null(obj$modelStruct$corStruct)) {\n                V <- corMatrix(obj$modelStruct$corStruct)[[as.character(individ)]]\n            }\n            else V <- diag(sum(ind))\n            if (!is.null(obj$modelStruct$varStruct)) \n                sds <- 1/varWeights(obj$modelStruct$varStruct)[ind]\n            else sds <- rep(1, sum(ind))\n            sds <- obj$sigma * sds\n            cond.var <- t(V * sds) * sds\n            dimnames(cond.var) <- list(1:nrow(cond.var), 1:ncol(cond.var))\n            if (type == \"conditional\") \n                result[[as.character(individ)]] <- cond.var\n            else {\n                Z <- model.matrix(obj$modelStruct$reStruc, getData(obj))[ind, \n                  , drop = FALSE]\n                result[[as.character(individ)]] <- cond.var + \n                  Z %*% D %*% t(Z)\n            }\n        }\n    }\n    class(result) <- c(type, \"VarCov\")\n    attr(result, \"group.levels\") <- names(obj$groups)\n    result\n}\n\nlme_raw <- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), \n               random = ~ 1 | Mare,\n               correlation = corExp(form = ~ Time),\n               weights = varPower(),\n               data=Ovary)\n\nlme_sorted <- update(lme_raw, data = Ovary_sorted)\n\nall.equal(lme_raw$modelStruct, lme_sorted$modelStruct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# current getVarCov\nV_raw <- lapply(Mares, function(g) getVarCov(lme_raw, individual = g, type = \"marginal\"))\nV_sorted <- lapply(Mares, function(g) getVarCov(lme_sorted, individual = g, type = \"marginal\"))\nall.equal(V_raw, V_sorted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n# revised getVarCov \nV_raw <- lapply(Mares, function(g) getVarCov_revised_lme(lme_raw, individual = g, type = \"marginal\"))\nV_sorted <- lapply(Mares, function(g) getVarCov_revised_lme(lme_sorted, individual = g, type = \"marginal\"))\nall.equal(V_raw, V_sorted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n# Session info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.3 (2024-02-29 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22621)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n[1] nlme_3.1-165\n\nloaded via a namespace (and not attached):\n [1] digest_0.6.35     fastmap_1.1.1     xfun_0.42         lattice_0.22-5   \n [5] knitr_1.45        htmltools_0.5.7   rmarkdown_2.26    cli_3.6.2        \n [9] grid_4.3.3        renv_1.0.5        compiler_4.3.3    rstudioapi_0.16.0\n[13] tools_4.3.3       evaluate_0.23     yaml_2.3.8        rlang_1.1.3      \n[17] jsonlite_1.8.8    htmlwidgets_1.6.4\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}