{
  "hash": "8594ee9a015b40aa3e343c6b9690a0a1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Simulating correlated standardized mean differences for meta-analysis\ndate: '2019-09-30'\nbibliography: \"../meta-references.bib\"\ncsl: \"../apa.csl\"\nlink-citations: true\ncategories:\n- effect size\n- standardized mean difference\n- meta-analysis\n- simulation\n- programming\n- distribution theory\ncode-tools: true\ntoc: true\ntoc-title: Contents\n---\n\n\nAs I've discussed in [previous posts](/posts/Sometimes-aggregating-effect-sizes-is-fine), meta-analyses in psychology, education, and other areas often include studies that contribute multiple, statistically dependent effect size estimates. \nI'm interested in methods for meta-analyzing and meta-regressing effect sizes from data structures like this, and studying this sort of thing often entails conducting Monte Carlo simulations.\nMonte Carlo simulations involve generating artificial data---in this case, a set of studies, each of which has one or more dependent effect size estimates---that follows a certain distributional model, applying different analytic methods to the artificial data, and then repeating the process a bunch of times.\nBecause we know the true parameters that govern the data-generating process, we can evaluate the performance of the analytic methods in terms of bias, accuracy, hypothesis test calibration and power, confidence interval coverage, and the like. \n\nIn this post, I'll discuss two alternative methods to simulate meta-analytic datasets that include studies with multiple, dependent effect size estimates: simulating individual participant-level data or simulating summary statistics. I'll focus on the case of the standardized mean difference (SMD) because it is so common in meta-analyses of intervention studies. For simplicity, I'll assume that the effect sizes all come from simple, two-group comparisons (without any covariate adjustment or anything like that) and that the individual observations are multi-variate normally distributed within each group. Our goal will be to simulate a set of $K$ studies, where study $k$ is based on measuring $J_k$ outcomes on a sample of $N_k$ participants, all for $k = 1,...,K$.\nLet $\\boldsymbol\\delta_k = (\\delta_{1k} \\cdots \\delta_{J_k k})'$ be the $J_k \\times 1$ vector of true standardized mean differences for study $k$. \nI'll assume that we know these true effect size parameters for all $K$ studies, so that I can avoid committing to any particular form of random effects model.\n\n# Simulating individual participant-level data\n\nThe most direct way to simulate this sort of effect size data is to generate outcome data for every artificial participant in every artificial study. Let $\\mathbf{Y}_{ik}^T$ be the $J_k \\times 1$ vector of outcomes for treatment group participant $i$ in study $k$, and let $\\mathbf{Y}_{ik}^C$ be the $J_k \\times 1$ vector outcomes for control group participant $i$ in study $k$, for $i=1,...,N_k / 2$ and $k = 1,...,K$. Assuming multi-variate normality of the outcomes, we can generate these outcome vectors as \n$$\n\\mathbf{Y}_{ik}^T \\sim N\\left(\\boldsymbol\\delta_k, \\boldsymbol\\Psi_k\\right) \\qquad \\text{and}\\qquad \\mathbf{Y}_{ik}^C \\sim N\\left(\\mathbf{0}, \\boldsymbol\\Psi_k\\right),\n$$\nwhere $\\boldsymbol\\Psi_k$ is the population correlation matrix of the outcomes in study $k$. \nNote that I am setting the mean outcomes of the control group participants to zero and also specifying that the outcomes all have unit variance within each group.\nAfter simulating data based on these distributions, the effect size estimates for each outcome can be calculated directly, following standard formulas.  \n\nHere's what this approach looks like in code. \nIt is helpful to simplify things by focusing on simulating just a single study with multiple, correlated effect sizes. \nFocusing first on just the input parameters, a function might look like the following:\n\n::: {.cell}\n\n```{.r .cell-code}\nr_SMDs_raw <- function(delta, J, N, Psi) {\n  # stuff\n  return(ES_data)  \n}\n```\n:::\n\nIn the above function skeleton, `delta` would be the true effect size parameter $\\boldsymbol\\delta_k$, `J` would be the number of effect sizes to generate $(J_k)$, `N` is the total number of participants $(N_k)$, and `Psi` is a matrix of correlations between the outcomes $(\\Psi_k)$.\nFrom these parameters, we'll generate raw data, calculate effect size estimates and standard errors, and return the results in a little dataset.\n\nTo make the function a little bit easier to use, I'm going overload the `Psi` argument so that it can be a single number, indicating a common correlation between the outcomes. Thus, instead of having to feed in a $J_k \\times J_k$ matrix, you can specify a single correlation $r_k$, and the function will assume that all of the outcomes are equicorrelated. In code, the logic is:\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!is.matrix(Psi)) Psi <- Psi + diag(1 - Psi, nrow = J)\n```\n:::\n\n\nHere's the function with the innards:\n\n::: {.cell}\n\n```{.r .cell-code}\nr_SMDs_raw <- function(delta, J, N, Psi) {\n\n  require(mvtnorm) # for simulating multi-variate normal data\n  \n  # create Psi matrix assuming equicorrelation\n  if (!is.matrix(Psi)) Psi <- Psi + diag(1 - Psi, nrow = J)\n  \n  # generate control group summary statistics\n  Y_C <- rmvnorm(n = N / 2, mean = rep(0, J), sigma = Psi)\n  ybar_C <- colMeans(Y_C)\n  sd_C <- apply(Y_C, 2, sd)\n  \n  # generate treatment group summary statistics\n  delta <- rep(delta, length.out = J)\n  Y_T <- rmvnorm(n = N / 2, mean = delta, sigma = Psi)\n  ybar_T <- colMeans(Y_T)\n  sd_T <- apply(Y_T, 2, sd)\n\n  # calculate Cohen's d\n  sd_pool <- sqrt((sd_C^2 + sd_T^2) / 2)\n  ES <- (ybar_T - ybar_C) / sd_pool\n  \n  # calculate SE of d\n  SE <- sqrt(4 / N + ES^2 / (2 * (N - 2)))\n\n  data.frame(ES = ES, SE = SE, N = N)\n\n}\n```\n:::\n\nIn action:\n\n::: {.cell}\n\n```{.r .cell-code}\ndelta <- rnorm(4, mean = 0.2, sd = 0.1)\nr_SMDs_raw(delta = delta, J = 4, N = 40, Psi = 0.6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          ES        SE  N\n1 0.20636715 0.3171125 40\n2 0.00944881 0.3162296 40\n3 0.05834946 0.3162986 40\n4 0.27005202 0.3177414 40\n```\n\n\n:::\n:::\n\nOr if you'd rather specify the full $\\Psi_k$ matrix yourself:\n\n::: {.cell}\n\n```{.r .cell-code}\nPsi_k <- 0.6 + diag(0.4, nrow = 4)\nPsi_k\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]  1.0  0.6  0.6  0.6\n[2,]  0.6  1.0  0.6  0.6\n[3,]  0.6  0.6  1.0  0.6\n[4,]  0.6  0.6  0.6  1.0\n```\n\n\n:::\n\n```{.r .cell-code}\nr_SMDs_raw(delta = delta, J = 4, N = 40, Psi = Psi_k)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         ES        SE  N\n1 0.7846964 0.3287886 40\n2 1.0052282 0.3365945 40\n3 1.0160157 0.3370204 40\n4 0.8310726 0.3302846 40\n```\n\n\n:::\n:::\n\n\n## Exercises\n\nThe function above is serviceable but quite basic. I can think of several additional features that one might like to have for use in research simulations, but I'm feeling both cheeky and lazy at the moment, so I'll leave them for you, dear reader. Here are some suggested exercises:\n\n1. Add an argument to the function, `Hedges_g = TRUE`, which controls where the simulated effect size is Hedges' $g$ or Cohen's $d$. If it is Hedges' g, make sure that the standard error is corrected too.\n\n2. Add an argument to the function, `p_val = TRUE`, which allows the user to control whether or not to return $p$-values from the test of mean differences for each outcome. Note that the p-values should be for a test of the _raw_ mean differences between groups, rather than a test of the effect size $\\delta_{jk} = 0$.\n\n3. Add an argument to the function, `corr_mat = FALSE`, which controls whether the function returns just the simulated effect sizes and SEs or both the simulated effect sizes and the full sampling variance-covariance matrix of the effect sizes. See [here](/posts/correlations-between-SMDs/) for the relevant formulas.\n\n# Simulating summary statistics\n\nAnother approach to simulating SMDs is to sample from the distribution of the _summary statistics_ used in calculating the effect size. This approach should simplify the code, at the cost of having to use a bit of distribution theory. Let $\\mathbf{\\bar{y}}_{Tk}$ and $\\mathbf{\\bar{y}}_{Ck}$ be the $J_k \\times 1$ vectors of sample means for the treatment and control groups, respectively. Let $\\mathbf{S}_k$ be the $J_k \\times J_k$ sample covariance matrix of the outcomes, pooled across the treatment and control groups. Again assuming multi-variate normality, and following the same notation as above:\n$$\n\\mathbf{\\bar{y}}_{Ck} \\sim N\\left(\\mathbf{0}, \\frac{2}{N_k} \\boldsymbol\\Psi_k\\right), \\qquad \\mathbf{\\bar{y}}_{Tk} \\sim N\\left(\\boldsymbol\\delta_k, \\frac{2}{N_k} \\boldsymbol\\Psi_k\\right),\n$$\nand\n$$\n\\left(\\mathbf{\\bar{y}}_{Tk} - \\mathbf{\\bar{y}}_{Ck}\\right) \\sim N\\left(\\boldsymbol\\delta_k, \\frac{4}{N_k} \\boldsymbol\\Psi_k\\right).\n$$\nThis shows how we could directly simulate the numerator of the standardized mean difference.\n\nA [further bit of distribution theory](/posts/distribution-of-sample-variances/) says that the pooled sample covariance matrix follows a multiple of a [Wishart distribution](https://en.wikipedia.org/wiki/Wishart_distribution) with $N_k - 2$ degrees of freedom and scale matrix $\\Psi_k$:\n$$\n(N_k - 2) \\mathbf{S}_k \\sim Wishart\\left(N_k - 2, \\Psi_k \\right).\n$$\nThus, to simulate the denominators of the SMD estimates, we can simulate a single Wishart matrix, pull out the diagonal entries, divide by $N_k - 2$, and take the square root. In all, we draw a single $J_k \\times 1$ observation from a multi-variate normal distribution and a single $J_k \\times J_k$ observation from a Wishart distribution. In contrast, the raw data approach requires simulating $N_k$ observations from a multi-variate normal distribution, then calculating $4 J_k$ summary statistics (M and SD for each group on each outcome). \n\n## Exercises\n\nOnce again, I'll leave it to you, dear reader, to do the fun programming bits:\n\n4. Create a modified version of the function `r_SMDs_raw` that simulates summary statistics instead of raw data (Call it `r_SMDs_stats`). \n\n5. Use the `microbenchmark` package (or your preferred benchmarking tool) to compare the computational efficiency of both versions of the function.\n\n6. Check your work! Verify that both versions of the function generate the same distributions if the same parameters are used as input. \n\n# Which approach is better?\n\nLike many things in research, there's no clearly superior method here. The advantage of the summary statistics approach is computational efficiency. It should generally be faster than the raw data approach, and if you need to generate 10,000 meta-analysis each with 80 studies in them, the computational savings might add up. On the other hand, computational efficiency isn't everything. \n\nI see two potential advantages of the raw data approach. First is interpretability: simulating raw data is likely easier to understand. It feels tangible and familiar, harkening back to those bygone days we spent learning ANOVA, whereas the summary statistics approach requires a bit of distribution theory to follow (bookmark this blog post!). Second is extensibility: it is relatively straightforward to extend the approach to use other distributional models for the raw dat (perhaps you want to look at outcomes that follow a [multi-variate $t$ distribution](https://en.wikipedia.org/wiki/Multivariate_t-distribution)?) or more complicated estimators of the SMD (difference-in-differences? covariate-adjusted? cluster-randomized trial?). To use the summary statistics approach in more complicated scenarios, you'd have to work out the sampling distributions for yourself, or locate the right reference.\n\nOf course, there's also no need to choose between these two approaches. As I'm trying to hint at in Exercise 6, it's actually useful to write both. Then, you can use the (potentially slower) raw data version to verify that the summary statistics version is correct.\n\n# Simulating full meta-analyses\n\nSo far we've got a data-generating function that simulates a single study's worth of effect size estimates. To study meta-analytic methods, we'll need to build out the function to simulate multiple studies. To do so, I think it's useful to use the technique of [mapping](https://r4ds.hadley.nz/iteration.html), as implemented in the `purrr` package's `map_*` functions. The idea here is to first generate a \"menu\" of study-specific parameters for each of $K$ studies, then apply the `r_SMDs` function to each parameter set. \n\nLet's consider how to do this for a simple random effects model, where the true effect size parameter is constant within each study (i.e., $\\boldsymbol\\delta_k = (\\delta_k \\cdots \\delta_k)'$), and in a model without covariates. We'll need to generate a true effect for each study, along with a sample size, an outcome dimension, and a correlation between outcomes. For the true effects, I'll assume that\n$$\n\\delta_k \\sim N(\\mu, \\tau^2),\n$$\n$$\nJ_k \\sim 2 + Poisson(3),\n$$\n$$\nN_k \\sim 20 + 2 \\times Poisson(10),\n$$\nand\n$$\nr_k \\sim Beta\\left(\\rho \\nu, (1 - \\rho)\\nu\\right),\n$$\nwhere $\\rho = \\text{E}(r_k)$ and $\\nu > 0$ controls the variability of $r_k$ across studies, with smaller $\\nu$ corresponding to more variable correlations. \nSpecifically, $\\text{Var}(r_k) = \\rho (1 - \\rho) / (1 + \\nu)$. \nThese distributions are just made up, without any particular justification.\n\nHere's what these distributional models look like in R code:\n\n::: {.cell}\n\n```{.r .cell-code}\nK <- 6\nmu <- 0.2\ntau <- 0.05\nJ_mean <- 5\nN_mean <- 45\nrho <- 0.6\nnu <- 39\n\nstudy_data <- \n  data.frame(\n    delta = rnorm(K, mean = mu, sd = tau),\n    J = 2 + rpois(K, J_mean - 2),\n    N = 20 + 2 * rpois(K, (N_mean - 20) / 2),\n    Psi = rbeta(K, rho * nu, (1 - rho) * nu)\n  )\n\nstudy_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      delta J  N       Psi\n1 0.1905403 5 48 0.6049361\n2 0.2134220 6 44 0.5660675\n3 0.2253686 4 30 0.6636925\n4 0.2058220 5 50 0.6208646\n5 0.1491957 3 50 0.5964943\n6 0.1322353 9 38 0.7402750\n```\n\n\n:::\n:::\n\nOnce we have the \"menu\" of study-level characteristics, it's just a matter of mapping the parameters to the data-generating function. One way to do this is with `pmap_df`:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nmeta_data <- pmap_df(study_data, r_SMDs_raw, .id = \"study\")\nmeta_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   study          ES        SE  N\n1      1  0.06517315 0.2887551 48\n2      1  0.34168631 0.2908648 48\n3      1  0.12496023 0.2889690 48\n4      1 -0.04072462 0.2887064 48\n5      1  0.09419262 0.2888421 48\n6      2 -0.36639431 0.3041500 44\n7      2  0.38766554 0.3044638 44\n8      2 -0.61520751 0.3088929 44\n9      2 -0.19841569 0.3022876 44\n10     2 -0.03526328 0.3015359 44\n11     2 -0.28365479 0.3030956 44\n12     3  0.36311779 0.3683584 30\n13     3  0.34736028 0.3680869 30\n14     3  0.16983695 0.3658530 30\n15     3  0.15218953 0.3657143 30\n16     4 -0.27633892 0.2842454 50\n17     4  0.17355790 0.2833968 50\n18     4  0.07927586 0.2829584 50\n19     4  0.05850698 0.2829057 50\n20     4  0.31610918 0.2846768 50\n21     5  0.50796626 0.2875549 50\n22     5  0.24858625 0.2839783 50\n23     5  0.32865767 0.2848248 50\n24     6  0.15205069 0.3249373 38\n25     6  0.04637057 0.3244889 38\n26     6  0.23761521 0.3256491 38\n27     6  0.32584452 0.3267075 38\n28     6  0.18745682 0.3251941 38\n29     6  0.05995579 0.3245198 38\n30     6  0.42337775 0.3282571 38\n31     6  0.45489411 0.3288422 38\n32     6  0.23466333 0.3256194 38\n```\n\n\n:::\n\n```{.r .cell-code}\ntable(meta_data$study)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n1 2 3 4 5 6 \n5 6 4 5 3 9 \n```\n\n\n:::\n:::\n\nPutting it all together into a function, we have\n\n::: {.cell}\n\n```{.r .cell-code}\nr_meta <- function(K, mu, tau, J_mean, N_mean, rho, nu) {\n  require(purrr)\n  \n  study_data <- \n    data.frame(\n      delta = rnorm(K, mean = mu, sd = tau),\n      J = 2 + rpois(K, J_mean - 2),\n      N = 20 + 2 * rpois(K, (N_mean - 20) / 2),\n      Psi = rbeta(K, rho * nu, (1 - rho) * nu)\n    )\n  \n  pmap_df(study_data, r_SMDs_raw, .id = \"study\")\n}\n```\n:::\n\n\n## Exercises\n\n7. Modify `r_meta` so that it uses `r_SMDs_stats`.\n\n8. Add options to `r_meta` for `Hedges_g`, `p_val = TRUE`, and `corr_mat = FALSE` and ensure that these get passed along to the `r_SMDs` function.\n\n9. One way to check that the `r_meta` function is working properly is to generate a very large meta-analytic dataset, then to verify that the generated distributions align with expectations. Here's a very large meta-analytic dataset:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    meta_data <- r_meta(\n      100000, \n      mu = 0.2, tau = 0.05, \n      J_mean = 5, N_mean = 40, \n      rho = 0.6, nu = 39\n    )\n    ```\n    :::\n\n    \n    Compare the distribution of the simulated dataset against what you would expect to get based on the input parameters.\n\n10. Modify the `r_meta` function so that $J_k$ and $N_k$ are correlated, according to\n    $$\n    \\begin{align}\n    J_k &\\sim 2 + Poisson(\\mu_J - 2) \\\\\n    N_k &\\sim 20 + 2 \\times Poisson\\left(\\frac{1}{2}(\\mu_N - 20) + \\alpha (J_k - \\mu_J) \\right)\n    \\end{align}\n    $$\n    for user-specified values of $\\mu_J$ (the average number of outcomes per study), $\\mu_N$ (the average total sample size per study), and $\\alpha$, which controls the degree of dependence between $J_k$ and $N_k$.\n    \n## A challenge\n\nThe meta-analytic model that we're using here is quite simple---simplistic, even---and for some simulation studies, something more complex might be needed. For example, we might need to generate data from a model that includes within-study random effects, as in:\n$$\n\\delta_{jk} = \\mu + u_k + v_{jk}, \\quad \\text{where}\\quad u_k \\sim N(0, \\tau^2), \\quad v_{jk} \\sim N(0, \\omega^2).\n$$\nEven more complex would be to simulate from a multi-level meta-regression model\n$$\n\\delta_{jk} = \\mathbf{x}_{jk} \\boldsymbol\\beta + u_k + v_{jk}, \\quad \\text{where}\\quad u_k \\sim N(0, \\tau^2), \\quad v_{jk} \\sim N(0, \\omega^2),\n$$\nwhere $\\mathbf{x}_{jk}$ is a $1 \\times p$ row-vector of covariates describing outcome $j$ in study $k$ and $\\boldsymbol\\beta$ is a $p \\times 1$ vector of meta-regression coefficients. In past work, I've done this by writing a data-generating function that takes a fixed design matrix $\\mathbf{X} = \\left(\\mathbf{x}_{11}' \\cdots \\mathbf{x}_{J_K K}'\\right)'$ as an input argument, along with $\\boldsymbol\\beta$. The design matrix would also include an identifier for each unique study. There are surely better (simpler, easier to follow) ways to implement the multi-level meta-regression model. I'll once again leave it to you to work out an approach.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}