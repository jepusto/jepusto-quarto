{
  "hash": "8a894314feebd9714de2ae48b1efa32a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Implementing Efron's double Poisson distribution in Stan\nauthors: admin\ndate: '2023-09-15'\ncategories:\n- Bayes\n- simulation\n- distribution-theory\n- generalized linear model\n- programming\n- Rstats\ncode-fold: show\ncode-tools: true\n\n---\n\n\n$$\n\\def\\Pr{{\\text{Pr}}}\n\\def\\E{{\\text{E}}}\n\\def\\Var{{\\text{Var}}}\n\\def\\Cov{{\\text{Cov}}}\n\\def\\bm{\\mathbf}\n\\def\\bs{\\boldsymbol}\n$$\n\nFor a project I am working on, we are using [Stan](https://mc-stan.org/) to fit generalized random effects location-scale models to a bunch of count data. We're interested in using the double-Poisson distribution, as described by [Efron (1986)](https://doi.org/10.2307/2289002). \nThis is an interesting distribution because it admits for both over- and under-dispersion relative to the Poisson distribution, whereas most of the conventional alternatives such as the negative binomial distribution or Poisson-normal mixture distribution allow only for over-dispersion. \nThe double-Poisson distribution is not implemented in Stan, so we've had to write our own distribution function. That's fine and not particularly difficult. What's a bit more of a challenge is writing Stan functions to generate random samples from the double-Poisson, so that we can generate posterior predictive checks.[^caveat] In this post, I'll walk through the implementation of the custom distribution functions needed to use the double-Poisson in Stan. \nThe [`gamlss.dist` package](https://cran.r-project.org/package=gamlss.dist) provides a full set of distributional functions for the double-Poisson distribution, including a sampler. Thus, I can validate my Stan functions against the functions from `gamlss.dist`.[^bamlss]\n\n[^caveat]: To be clear up front, what I present is more complicated than really necessary because of these existing R functions to simulate values from the double-Poisson---we can just use the functions from `gamlss.dist` for purposes of posterior predictive checks (about which more below). \nI'm trying to work in Stan to the maximum extent possible solely as an excuse to learn more about the language, which I haven't used much up until today.\n\n[^bamlss]: I should also note that the [`bamlss` package](http://www.bamlss.org/index.html) provides similar functionality and can be combined with `gamlss.dist` to accomplish basically the same thing as I'm going to do here.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(patchwork)   # composing figures\nlibrary(gamlss.dist) # DPO distribution functions\nlibrary(rstan)       # Stan interface to R\nlibrary(brms)        # fitting generalized linear models\nlibrary(bayesplot)   # Examine fitted models\nlibrary(loo)         # Model fit measures\n```\n:::\n\n\n## The double-Poisson \n\nThe double-Poisson distribution is a discrete distribution for non-negative counts, with support $\\mathcal{S}_X = \\{0, 1, 2, 3, ...\\}$. \nThe mean-variance relationship of the double-Poisson is approximately constant; for $X \\sim DPO(\\mu, \\phi)$,  $\\text{E}(X) \\approx \\mu$ and $\\text{Var}(X) \\approx \\mu / \\phi$, so that the double-Poisson distribution approximately satisfies the assumptions of a quasi-Poisson generalized linear model (although not quite exactly so). \n\n[Efron (1986)](https://doi.org/10.2307/2289002) gives the following expression for the density of the double-Poisson distribution with mean $\\mu$ and inverse-disperson $\\phi$:\n$$\nf(x | \\mu, \\phi) = \\frac{\\phi^{1/2} e^{-\\phi \\mu}}{c(\\mu,\\phi)} \\left(\\frac{e^{-x} x^x}{x!}\\right) \\left(\\frac{e \\mu}{x}\\right)^{\\phi x},\n$$\nwhere $c(\\mu,\\phi)$ is a scaling constant to ensure that the density sums to one, which is closely approximated by \n$$\nc(\\mu, \\phi) \\approx 1 + \\frac{1 - \\phi}{12 \\mu \\phi}\\left(1 + \\frac{1}{\\mu \\phi}\\right).\n$$\nWe then have\n$$\n\\ln f(x | \\mu, \\phi) = \\frac{1}{2} \\ln \\phi - \\phi \\mu - \\ln c(\\mu, \\phi) + x (\\phi + \\phi \\ln \\mu - 1) + (1 - \\phi) x \\ln(x) - \\ln \\left(x!\\right),\n$$\nwhere $0 \\times \\ln (0)$ is evaluated as 0.\n\n# Log of the probability mass function\n\nFor purposes of using this distribution in Stan, it's sufficient to provide the log of the probability mass function up to a constant---there's no need to normalize it to sum to one. Thus, we can ignore the $c(\\mu, \\phi)$ term above. Here's a Stan function implementing the lpmf:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstancode_lpmf <- \"\nreal dpo_lpmf(int X, real mu, real phi) {\n  real ans;\n  real A = inv(2) * log(phi) - phi * mu;\n  if (X == 0)\n    ans = A;\n  else\n    ans = A + X * (phi * (1 + log(mu)) - 1) - lgamma(X + 1) + (1 - phi) * X * log(X);\n  return ans;\n}\n\"\n```\n:::\n\n\nTo check that this is accurate, I'll compare the Stan function to the corresponding function from `gamlss.dist` for a couple of different parameter values and for $x = 0,...,100$. If my function is accurate, the calculated log-probabilities should differ by a constant value for each set of parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteLines(paste(\"functions {\", stancode_lpmf, \"}\", sep = \"\\n\"), \"DPO-lpmf.stan\")\nexpose_stan_functions(\"DPO-lpmf.stan\")\n\ntest_lpmf <- \n  expand_grid(\n    mu = c(2, 5, 10, 20),\n    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),\n    X = 0:100\n  ) %>%\n  mutate(\n    gamlss_lpmf = dDPO(x = X, mu = mu, sigma = 1 / phi, log = TRUE),\n    my_lpmf = pmap_dbl(.l = list(X = X, mu = mu, phi = phi), .f = dpo_lpmf),\n    diff = my_lpmf - gamlss_lpmf\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(test_lpmf, aes(factor(phi), diff, color = factor(phi))) + \n  geom_boxplot() + \n  facet_wrap( ~ mu, labeller = \"label_both\", ncol = 2) + \n  theme_minimal() + \n  labs(x = \"phi\") + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nChecks out. Onward!\n\n# Cumulative distribution function\n\nI'll next implement a function to evaluate the cumulative distriution function over a range of values. This is an expensive calculation, but it can be improved a little bit by noting the relationship between sequential values of the probability mass function. Letting $d = \\exp \\left(\\phi + \\phi \\ln \\mu - 1 \\right)$, observe that\n$$\n\\begin{aligned}\nf(0 | \\mu, \\phi) &= \\frac{\\phi^{1/2} e^{-\\phi \\mu}}{c(\\mu,\\phi)} \\\\\nf(1 | \\mu, \\phi) &= f(0 | \\mu, \\phi) \\times d \\\\\nf(x | \\mu, \\phi) &= f(x - 1 | \\mu, \\phi) \\times d \\times \\frac{\\exp\\left[(1 - \\phi)(x - 1)\\left(\\ln(x) - \\ln(x - 1)\\right) \\right]}{x^\\phi}\n\\end{aligned}\n$$\nwhere the last expression holds for $x \\geq 2$.\n\nThe function below computes the cumulative distribution function over the range $x = 0,...,m$ as follows: \n\n* Compute $f(x | \\mu, \\phi)$ for $x = 0,1,2,...$, without the scaling constant $c(\\mu, \\phi)$\n* Take $F(0 | \\mu, \\phi) = f(0 | \\mu, \\phi)$ and accumulate $F(x | \\mu, \\phi) = F(x - 1 | \\mu, \\phi) + f(x | \\mu, \\phi)$ for $x = 0,...,m$.\n* Check if $f(x | \\mu, \\phi) / F(x | \\mu, \\phi)$ is small (less than $10^{-8}$), in which case accumulation stops at the value $n$.\n* The normalized cumulative distribution function will then be $F(x | \\mu, \\phi) / F(n | \\mu, \\phi)$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstancode_cdf <- \" \nvector dpo_cdf_vec(real mu, real phi, int maxval) {\n  real d = exp(phi * (1 + log(mu)) - 1);\n  real prob;\n  int n = maxval + 1;\n  vector[n] cdf;\n  cdf[1] = sqrt(phi) * exp(-mu * phi);\n  prob = cdf[1] * d;\n  cdf[2] = cdf[1] + prob;\n  for (i in 2:maxval) {\n    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);\n    cdf[i + 1] = cdf[i] + prob;\n    if (prob / cdf[i + 1] < 1e-8) {\n      n = i + 1;\n      break;\n    }\n  }\n  return cdf / cdf[n];\n}\n\"\n```\n:::\n\n\nTo check that this is accurate, I'll again compare the Stan function to the corresponding function from `gamlss.dist`. If my function is accurate, the computed cdf values should be proportional to the cdf calculated from `gamlss.dist::pDPO()` and the ratio should be very close to 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteLines(paste(\"functions {\", stancode_cdf, \"}\", sep = \"\\n\"), \"DPO-cdf.stan\")\nexpose_stan_functions(\"DPO-cdf.stan\")\n\ntest_cdf <- \n  expand_grid(\n    mu = c(2, 5, 10, 20),\n    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),\n  ) %>%\n  mutate(\n    maxval = 20 * mu / pmin(1, phi),\n    my_cdf = pmap(.l = list(mu = mu, phi = phi, maxval = maxval), .f = dpo_cdf_vec)\n  ) %>%\n  unnest(my_cdf) %>%\n  filter(!is.nan(my_cdf)) %>%\n  group_by(mu, phi) %>%\n  mutate(\n    q = row_number() - 1L,\n    gamlss_cdf = pDPO(q = q, mu = mu, sigma = 1 / phi),\n    ratio = my_cdf / gamlss_cdf\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(test_cdf, aes(factor(phi), ratio, color = factor(phi))) + \n  geom_boxplot() + \n  facet_wrap( ~ mu, labeller = \"label_both\", ncol = 2) + \n  theme_minimal() + \n  labs(x = \"phi\") + \n  ylim(1 + c(-1e-6, 1e-6)) + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nStill on track here (although you might wonder---would I be sharing this post if I couldn't get the function working?).\n\n# Quantile function and sampler\n\nThe main other thing we need is a function for generating random samples from the double-Poisson. The `gamlss.dist` package has the function `rDPO()` for this purpose. It's implemented using the standard inversion method, by calculating quantiles of the double-Poisson corresponding to a random sample from a uniform distribution. Just for funzies, I'll implement the same approach using Stan.\n\nThe function below calculates quantiles by finding the minimum value of $q \\geq 0$ such that $F(q + 1 | \\mu, \\phi) \\geq p$ for a specified probability $p \\in [0, 1]$. It is vectorized over $p$ and solves for $q$ by starting with the smallest $p$ and continuing through the largest value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstancode_quantile <- \" \nvector dpo_cdf_vec(real mu, real phi, int maxval) {\n  real d = exp(phi * (1 + log(mu)) - 1);\n  real prob;\n  int n = maxval + 1;\n  vector[n] cdf;\n  cdf[1] = sqrt(phi) * exp(-mu * phi);\n  prob = cdf[1] * d;\n  cdf[2] = cdf[1] + prob;\n  for (i in 2:maxval) {\n    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);\n    cdf[i + 1] = cdf[i] + prob;\n    if (prob / cdf[i + 1] < 1e-8) {\n      n = i + 1;\n      break;\n    }\n  }\n  return cdf / cdf[n];\n}\narray[] int dpo_quantiles(vector p, real mu, real phi, int maxval) {\n  int N = rows(p);\n  array[N] int qs;\n  array[N] int indices = sort_indices_asc(p);\n  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);\n  int j = 0;\n  for (i in indices) {\n    while (cdf_vec[j + 1] < p[i]) {\n      j += 1;\n    }\n    qs[i] = j;\n  }\n  return qs;\n}\n\"\n```\n:::\n\n\nIf my quantile function is accurate, it should match the value computed from `gamlss.dist::qDPO()` exactly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteLines(paste(\"functions {\", stancode_quantile, \"}\", sep = \"\\n\"), \"DPO-quantile.stan\")\nexpose_stan_functions(\"DPO-quantile.stan\")\n\ntest_quantile <- \n  expand_grid(\n    mu = c(2, 5, 10, 20),\n    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),\n  ) %>%\n  mutate(\n    maxval = 20 * mu / pmin(1, phi),\n    p = map(1:n(), ~ runif(100)),\n    my_q = pmap(.l = list(p = p, mu = mu, phi = phi, maxval = maxval), .f = dpo_quantiles),\n    gamlss_q = pmap(.l = list(p = p, mu = mu, sigma = 1 / phi), .f = qDPO)\n  ) %>%\n  unnest(c(p, my_q, gamlss_q)) %>%\n  mutate(\n    diff = my_q - gamlss_q\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(test_quantile, aes(factor(phi), diff, color = factor(phi))) + \n  geom_boxplot() + \n  facet_wrap( ~ mu, labeller = \"label_both\", ncol = 2) + \n  theme_minimal() + \n  labs(x = \"phi\") + \n  theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nPhew, still got it!\n\nThe last piece of the puzzle is to write a sampler by generating random points from a uniform distribution, then computing the double-Poisson quantiles of these random points. I will implement this two ways: first with an argument for the number of random variates to generate and then, more simply, to generate a single random variate.[^clever] \n\n[^clever]: The simpler version is what's needed for generating posterior predictive checks, the fancy version is just to show off how clever I am.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstancode_qr <- \"\nreal dpo_lpmf(int X, real mu, real phi) {\n  real ans;\n  real A = inv(2) * log(phi) - phi * mu;\n  if (X == 0)\n    ans = A;\n  else\n    ans = A + X * (phi * (1 + log(mu)) - 1) - lgamma(X + 1) + (1 - phi) * X * log(X);\n  return ans;\n}\nvector dpo_cdf_vec(real mu, real phi, int maxval) {\n  real d = exp(phi * (1 + log(mu)) - 1);\n  real prob;\n  int n = maxval + 1;\n  vector[n] cdf;\n  cdf[1] = sqrt(phi) * exp(-mu * phi);\n  prob = cdf[1] * d;\n  cdf[2] = cdf[1] + prob;\n  for (i in 2:maxval) {\n    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);\n    cdf[i + 1] = cdf[i] + prob;\n    if (prob / cdf[i + 1] < 1e-8) {\n      n = i + 1;\n      break;\n    }\n  }\n  return cdf / cdf[n];\n}\narray[] int dpo_quantiles(vector p, real mu, real phi, int maxval) {\n  int N = rows(p);\n  array[N] int qs;\n  array[N] int indices = sort_indices_asc(p);\n  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);\n  int j = 0;\n  for (i in indices) {\n    while (cdf_vec[j + 1] < p[i]) {\n      j += 1;\n    }\n    qs[i] = j;\n  }\n  return qs;\n}\narray[] int dpo_sample_rng(int n, real mu, real phi, int maxval) {\n  vector[n] p;\n  for (i in 1:n) {\n    p[i] = uniform_rng(0,1);\n  }\n  array[n] int x = dpo_quantiles(p, mu, phi, maxval);\n  return x;\n}\nint dpo_quantile(real p, real mu, real phi, int maxval) {\n  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);\n  int q = 0;\n  while (cdf_vec[q + 1] < p) {\n      q += 1;\n    }\n  return q;\n}\nint dpo_rng(real mu, real phi, int maxval) {\n  real p = uniform_rng(0,1);\n  int x = dpo_quantile(p, mu, phi, maxval);\n  return x;\n}\n\"\n```\n:::\n\n\nTo check this function, I'll generate some large samples from the double-Poisson with a few different parameter sets. If the sampler is working properly, the empirical cumulative distribution should line up closely with the cumulative distribution computed using `gamlss.dist::pDPO()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteLines(paste(\"functions {\", stancode_qr, \"}\", sep = \"\\n\"), \"DPO-rng.stan\")\nexpose_stan_functions(\"DPO-rng.stan\")\n\ntest_rng <- \n  expand_grid(\n    mu = c(2, 5, 10, 20),\n    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),\n  ) %>%\n  mutate(\n    x = pmap(.l = list(n = 10000, mu = mu, phi = phi, maxval = 5000), .f = dpo_sample_rng),\n    tb = map(x, ~ as.data.frame(table(.x)))\n  ) %>%\n  dplyr::select(-x) %>%\n  group_by(mu, phi) %>%\n  unnest(tb) %>%\n  mutate(\n    .x = as.integer(levels(.x))[.x],\n    Freq_cum = cumsum(Freq) / 10000,\n    gamlss_F = pDPO(q = .x, mu = mu, sigma = 1 / phi)\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(test_rng, aes(gamlss_F, Freq_cum, color = factor(phi))) + \n  geom_abline(slope = 1, color = \"blue\", linetype = \"dashed\") + \n  geom_point() + geom_line() +  \n  facet_grid(phi ~ mu, labeller = \"label_both\") + \n  theme_minimal() + \n  labs(x = \"Theoretical cdf (gamlss.dist)\", y = \"Empirical cdf (my function)\") + \n  theme(legend.position = \"none\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nLooks pretty good, no?\n\n# Using the custom distribution functions\n\nTo finish out my tests of these functions, let me demonstrate their use in an actual estimation problem. I'll generate data based on a simple generalized linear model with a single predictor $X$, where the outcome $Y$ follows a double-Poisson distribution conditional on $X$. The data-generating process is:\n\n$$\n\\begin{aligned}\nX &\\sim N(0, 1) \\\\\nY|X &\\sim DPO(\\mu(X), \\phi) \\\\\n\\log \\mu(X) &= 2 + 0.3 \\times X\n\\end{aligned}\n$$\nTo make things interesting, I'll set the dispersion parameter to $1 / \\phi = 0.6$ so that the outcome is _under_-dispersed relative to the Poisson. \n\nThe following code generates a large sample from the data-generating process. To keep things R-centric, I use `gamlss.dist::rDPO` to generate the outcome.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20230913)\nN <- 600\nX <- rnorm(N)\nmu <- exp(2 + 0.3 * X)\nphi_inv <- 0.6\nY <- rDPO(N, mu = mu, sigma = phi_inv)\ndat <- data.frame(X = X, Y = Y)\n```\n:::\n\n\nHere's what the sample looks like, along with a smoothed regression estimated using a basic cubic spline:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dat, aes(X, Y)) + \n  geom_point(alpha = 0.1) + \n  geom_smooth(method = 'gam', formula = y ~ s(x, bs = \"cs\")) + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=576}\n:::\n:::\n\n\n## Comparison models\n\nBefore using the custom distribution, I'll fit a couple of out-of-the-box models that are useful points of comparison. \nSurely the simplest, quickest, and dirtiest way to estimate such a regression is with a generalized linear model, using the \"quasi-Poisson\" family to allow for non-unit dispersion. In R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquasi_fit <- glm(Y ~ X, family = quasipoisson(link = \"log\"), data = dat)\nsummary(quasi_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = Y ~ X, family = quasipoisson(link = \"log\"), data = dat)\n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  1.98784    0.01219  163.03   <2e-16 ***\nX            0.29276    0.01178   24.85   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for quasipoisson family taken to be 0.6324771)\n\n    Null deviance: 777.74  on 599  degrees of freedom\nResidual deviance: 384.90  on 598  degrees of freedom\nAIC: NA\n\nNumber of Fisher Scoring iterations: 4\n```\n\n\n:::\n:::\n\n\nThis approach recovers the data-generating parameters quite well, with a dispersion estimate of 0.632 compared to the true dispersion parameter of 0.6. \n\nNow let me fit the same generalized linear model but assuming that the outcome follows a true Poisson distribution (with unit dispersion). I'll fit the model in a Bayesian framework with the `brms` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPoisson_fit <- \n  brm(\n    Y ~ X, family = poisson(link = \"log\"),\n    data = dat, \n    warmup = 500, \n    iter = 1500, \n    chains = 4, \n    cores = 4,\n    seed = 20230913\n  )\n\nsummary(Poisson_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: poisson \n  Links: mu = log \nFormula: Y ~ X \n   Data: dat (Number of observations: 600) \n  Draws: 4 chains, each with iter = 1500; warmup = 500; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     1.99      0.02     1.96     2.02 1.00     2865     2658\nX             0.29      0.01     0.26     0.32 1.00     2552     2381\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\nThis specification recovers the intercept and slope parameters well too, but doesn't provide any estimate of dispersion. \n\nAs an alternative, I'll also fit the model using the negative binomial distribution, which is a generalization of the Poisson that allows for over-dispersion (but not under-dispersion):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnegbin_fit <- \n  brm(\n    Y ~ X, family = negbinomial(link = \"log\"),\n    data = dat, \n    warmup = 500, \n    iter = 1500, \n    chains = 4, \n    cores = 4,\n    seed = 20230913\n  )\n\nsummary(negbin_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: negbinomial \n  Links: mu = log; shape = identity \nFormula: Y ~ X \n   Data: dat (Number of observations: 600) \n  Draws: 4 chains, each with iter = 1500; warmup = 500; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS\nIntercept     1.98      0.01     1.96     1.99  8.46        4        4\nX             0.31      0.03     0.29     0.36 11.39        4       NA\n\nFurther Distributional Parameters:\n                                                                                                                      Estimate\nshape 288635341964439312984004668864260822628440088608000200668088264284802644482664682404200862480406040224646204882688664.00\n                                                                                                                     Est.Error\nshape 499993580246645223926226042864464406466686242028244246282864888460026284662046208044222402820440664060080422624068464.00\n               l-95% CI\nshape 12948941308882.21\n                                                                                                                       u-95% CI\nshape 1154541367857757248926006442246840288482660022402000800442022846826208466628446428606800248620604060886464806228422446.00\n      Rhat Bulk_ESS Tail_ESS\nshape  Inf        4       NA\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\nThe `brms` package implements the negative binomial using the rate parameterization, so the `shape` parameter corresponds to the inverse dispersion. Thus, a large shape parameter (as in the above fit) implies dispersion that is very close to one (i.e., close to the Poisson).\n\n## Double-Poisson model\n\nNow I'll fit the same model as previously but using my custom-built double-Poisson distribution. Following [Paul Buerkner's vignette](https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html) on using custom distributions in `brms`, I'll first specify the custom family object for the double-Poisson:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble_Poisson <- custom_family(\n  \"dpo\", dpars = c(\"mu\",\"phi\"),\n  links = c(\"log\",\"log\"),\n  lb = c(0, 0), ub = c(NA, NA),\n  type = \"int\"\n)\n```\n:::\n\n\nI set the defaults to use a log-link for the mean (just as with the Poisson and negative binomial families) and a log-link for the inverse-dispersion. \nNext, I'll create an object to add the custom stan code from above into the code created by `brm` for fitting the model:\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble_Poisson_stanvars <- stanvar(scode = stancode_qr, block = \"functions\")\n```\n:::\n\nI'll also need to specify a prior to use for the $\\phi$ parameter of the double-Poisson distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nphi_prior <- prior(exponential(1), class = \"phi\")\n```\n:::\n\n\nNow I'm ready to fit the model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDPO_fit <- \n  brm(\n    Y ~ X, family = double_Poisson,\n    prior = phi_prior,\n    stanvars = double_Poisson_stanvars,\n    data = dat, \n    warmup = 500, \n    iter = 1500, \n    chains = 4, \n    cores = 4,\n    seed = 20230913\n  )\n\nsummary(DPO_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Family: dpo \n  Links: mu = log; phi = identity \nFormula: Y ~ X \n   Data: dat (Number of observations: 600) \n  Draws: 4 chains, each with iter = 1500; warmup = 500; thin = 1;\n         total post-warmup draws = 4000\n\nRegression Coefficients:\n          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nIntercept     1.99      0.01     1.96     2.01 1.00     3592     2849\nX             0.29      0.01     0.27     0.32 1.00     3330     3103\n\nFurther Distributional Parameters:\n    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\nphi     1.55      0.09     1.38     1.72 1.00     3043     2560\n\nDraws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\nand Tail_ESS are effective sample size measures, and Rhat is the potential\nscale reduction factor on split chains (at convergence, Rhat = 1).\n```\n\n\n:::\n:::\n\n\nThe regression coefficient estimates are basically identical to those from the Poisson and negative-binomial models, estimated with slightly better precision than with the Poisson or negative binomial families. However, we get a posterior for $\\phi$ that corresponds to _under_-dispersion. Here's the posterior for the dispersion (i.e., $1 / \\phi$):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_areas(DPO_fit, pars = \"phi\", transformations = \\(x) 1 / x) + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/DPO-dispersion-1.png){width=480}\n:::\n:::\n\n\n## Model comparison\n\nI'd like to get a sense of how much better the double-Poisson model does with capturing the real data-generating process compared to the simple Poisson model or the negative binomial model. There's a wide range of diagnostics that can inform such comparisons. I'll consider the leave-one-out information criteria (LOOIC) and also look at some posterior predictive checks.\n\nTo calculate LOOIC for the double-Poisson model, I first need to provide a `log_lik` function that `brms` can use[^loglik-in-R]. Here's code, using the Stan function from above:\n\n::: {.cell}\n\n```{.r .cell-code}\nexpose_functions(DPO_fit, vectorize = TRUE)\nlog_lik_dpo <- function(i, prep) {\n  mu <- brms::get_dpar(prep, \"mu\", i = i)\n  phi <- brms::get_dpar(prep, \"phi\", i = i)\n  y <- prep$data$Y[i]\n  dpo_lpmf(y, mu, phi)\n}\n```\n:::\n\n\n[^loglik-in-R]: Rather than exposing and calling the Stan function, one could just re-implement the log likelihood in R. (Probably the easier way in practice, but again I'm trying to learn me some Stan here...)\n\nI can then compute LOOIC for all three models:\n\n::: {.cell}\n\n```{.r .cell-code}\nloo(DPO_fit, Poisson_fit, negbin_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nOutput of model 'DPO_fit':\n\nComputed from 4000 by 600 log-likelihood matrix.\n\n         Estimate   SE\nelpd_loo  -1305.7 16.9\np_loo         2.9  0.2\nlooic      2611.4 33.7\n------\nMCSE of elpd_loo is 0.0.\nMCSE and ESS estimates assume MCMC draws (r_eff in [0.7, 1.3]).\n\nAll Pareto k estimates are good (k < 0.7).\nSee help('pareto-k-diagnostic') for details.\n\nOutput of model 'Poisson_fit':\n\nComputed from 4000 by 600 log-likelihood matrix.\n\n         Estimate   SE\nelpd_loo  -1330.0 11.3\np_loo         1.3  0.1\nlooic      2660.1 22.6\n------\nMCSE of elpd_loo is 0.0.\nMCSE and ESS estimates assume MCMC draws (r_eff in [0.5, 0.9]).\n\nAll Pareto k estimates are good (k < 0.7).\nSee help('pareto-k-diagnostic') for details.\n\nOutput of model 'negbin_fit':\n\nComputed from 4000 by 600 log-likelihood matrix.\n\n         Estimate   SE\nelpd_loo  -1332.9 11.6\np_loo         2.9  0.3\nlooic      2665.8 23.2\n------\nMCSE of elpd_loo is NA.\nMCSE and ESS estimates assume MCMC draws (r_eff in [0.0, 0.0]).\n\nPareto k diagnostic values:\n                         Count Pct.    Min. ESS\n(-Inf, 0.7]   (good)     157   26.2%   2       \n   (0.7, 1]   (bad)        0    0.0%   <NA>    \n   (1, Inf)   (very bad) 443   73.8%   <NA>    \nSee help('pareto-k-diagnostic') for details.\n\nModel comparisons:\n            elpd_diff se_diff\nDPO_fit       0.0       0.0  \nPoisson_fit -24.3       6.0  \nnegbin_fit  -27.2       6.0  \n```\n\n\n:::\n:::\n\nBy these measures, the double-Poisson model has substantially better fit than either of the other models. \n\nTo do posterior predictive checks, I need to provide a `posterior_predict` function that `brms` can use. I'll again do an implementation that uses my custom `dpo_rng()` from Stan.[^PP-in-R]\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior_predict_dpo <- function(i, prep, maxval = NULL, ...) {\n  mu <- brms::get_dpar(prep, \"mu\", i = i)\n  phi <- brms::get_dpar(prep, \"phi\", i = i)\n  if (is.null(maxval)) maxval <- 20 * mu / min(phi, 1)\n  dpo_rng(mu, phi, maxval = maxval)\n}\n```\n:::\n\n\n[^PP-in-R]: Of course, I could have saved a bunch of trouble by just using `gamlss.dist::rDPO()` instead.\n\nFunctions in hand, I can now compute posterior predictions for the double-Poisson model and make pretty pictures of them, along with corresponding plots for the Poisson and negative-binomial models.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nYrep_Poisson <- posterior_predict(Poisson_fit, draws = 400) \ncolor_scheme_set(\"blue\")\nPoisson_root <- ppc_rootogram(dat$Y, Yrep_Poisson, style = \"hanging\") + labs(title = \"Poisson\")\n\nYrep_negbin <- posterior_predict(negbin_fit, draws = 400)\ncolor_scheme_set(\"green\")\nnegbin_root <- ppc_rootogram(dat$Y, Yrep_negbin, style = \"hanging\") + labs(title = \"Negative-binomial\")\n\nYrep_dpo <- posterior_predict(DPO_fit, draws = 400)\ncolor_scheme_set(\"purple\")\ndpo_root <- ppc_rootogram(dat$Y, Yrep_dpo, style = \"hanging\") + labs(title = \"Double-Poisson\")\n\ndpo_root / Poisson_root / negbin_root &\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ppd-1.png){width=768}\n:::\n:::\n\n\nThe differences in predicted frequencies are not that obvious from these plots. The main notable difference is that the Poisson and negative-binomial distributions predict more small counts (in the range of 0 to 3) than are observed, whereas the double-Poisson does better at matching the observed frequency in this range.\n\nI think the lack of glaring differences in the above plots happens because I'm just looking at the marginal distribution of the outcome, and the (explained) variation due to the predictor dampens the degree of under-dispersion. To see this, I'll create some plots that are grouped by quintiles of $X$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat$g <- cut(dat$X, breaks = quantile(dat$X, seq(0,1,0.2)), include.lowest = TRUE)\n\ncolor_scheme_set(\"blue\")\nPoisson_bars <- ppc_bars_grouped(\n  dat$Y, Yrep_Poisson, dat$g, \n  prob = 0.5, \n  facet_args = list(ncol = 5)\n) + \n  labs(title = \"Poisson\")\n\ncolor_scheme_set(\"green\")\nnegbin_bars <- ppc_bars_grouped(\n  dat$Y, Yrep_negbin, dat$g, \n  prob = 0.5, \n  facet_args = list(ncol = 5)\n) + \n  labs(title = \"Negative-binomial\")\n\ncolor_scheme_set(\"purple\")\ndpo_bars <- ppc_bars_grouped(\n  dat$Y, Yrep_dpo, dat$g, \n  prob = 0.5, \n  facet_args = list(ncol = 5)\n) + \n  labs(title = \"Double-Poisson\")\n\ndpo_bars / Poisson_bars / negbin_bars &\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ppd-grouped-1.png){width=1152}\n:::\n:::\n\nStill kind of subtle, I suppose, but you can see more clearly that the double-Poisson does a better job than the other distributions at matching the modes (peaks) of the empirical distribution in each of these subgroups.\n\nOne last approach is to look directly at the degree of dispersion in the posterior predictive distributions relative to the actual data. I'll calculate this dispersion by re-fitting the quick-and-dirty quasi-poisson model in each sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndispersion_coef <- function(y) {\n  quasi_fit <- glm(y ~ dat$X, family = quasipoisson(link = \"log\"))\n  sum(residuals(quasi_fit, type = \"pearson\")^2) / quasi_fit$df.residual\n}\n\ncolor_scheme_set(\"blue\")\nPoisson_disp <- ppc_stat(dat$Y, Yrep_Poisson, stat = dispersion_coef, binwidth = 0.02) + \n  labs(title = \"Poisson\")\n\ncolor_scheme_set(\"green\")\nnegbin_disp <- ppc_stat(dat$Y, Yrep_negbin, stat = dispersion_coef, binwidth = 0.02) + \n  labs(title = \"Negative-binomial\")\n\ncolor_scheme_set(\"purple\")\ndpo_disp <- ppc_stat(dat$Y, Yrep_dpo, stat = dispersion_coef, binwidth = 0.02) + \n  labs(title = \"Double-Poisson\")\n\ndpo_disp / Poisson_disp / negbin_disp &\n  theme_minimal() & \n  xlim(c(0.45, 1.3))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ppc-dispersion-1.png){width=768}\n:::\n:::\n\n\nFrom this, we can clearly see that the Poisson and negative binomial model generate data with approximately unit dispersion, which doesn't match at all with the degree of dispersion in the observed data. \n\n# Kudos\n\nSo there you have it. It's really quite feasible to build models with custom distributions. Efron (1986) also describes a double-binomial distribution (as an approximation to the \"quasi-binomial\" family of generalized linear models), which you could play with implementing for yourself, dear reader, if you are in the mood. \nMajor kudos to [Paul Buerkner](https://paul-buerkner.github.io/) for [`brms`](https://paul-buerkner.github.io/brms/), [Jonah Gabry](https://jgabry.github.io/) and collaborators for [`bayesplot`](https://mc-stan.org/bayesplot/), and [the incredible team of folks](https://mc-stan.org/about/team/) developing [`Stan`](https://mc-stan.org/).\n\n# Colophon\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.3 (2024-02-29 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 11 x64 (build 22621)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Chicago\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] loo_2.7.0          bayesplot_1.11.1   brms_2.21.0        Rcpp_1.0.12       \n [5] rstan_2.32.6       StanHeaders_2.32.6 gamlss.dist_6.1-1  patchwork_1.2.0   \n [9] lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1      dplyr_1.1.4       \n[13] purrr_1.0.2        readr_2.1.5        tidyr_1.3.1        tibble_3.2.1      \n[17] ggplot2_3.5.0      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.2.1     farver_2.1.1         fastmap_1.1.1       \n [4] tensorA_0.36.2.1     digest_0.6.35        timechange_0.3.0    \n [7] lifecycle_1.0.4      magrittr_2.0.3       posterior_1.5.0     \n[10] compiler_4.3.3       rlang_1.1.3          tools_4.3.3         \n[13] utf8_1.2.4           yaml_2.3.8           knitr_1.45          \n[16] labeling_0.4.3       bridgesampling_1.1-2 htmlwidgets_1.6.4   \n[19] pkgbuild_1.4.4       plyr_1.8.9           BH_1.84.0-0         \n[22] abind_1.4-5          withr_3.0.0          grid_4.3.3          \n[25] stats4_4.3.3         fansi_1.0.6          colorspace_2.1-0    \n[28] inline_0.3.19        scales_1.3.0         MASS_7.3-60.0.1     \n[31] ggridges_0.5.6       cli_3.6.2            mvtnorm_1.2-4       \n[34] rmarkdown_2.26       generics_0.1.3       RcppParallel_5.1.7  \n[37] rstudioapi_0.16.0    reshape2_1.4.4       tzdb_0.4.0          \n[40] splines_4.3.3        parallel_4.3.3       matrixStats_1.2.0   \n[43] vctrs_0.6.5          Matrix_1.6-5         jsonlite_1.8.8      \n[46] hms_1.1.3            glue_1.7.0           codetools_0.2-19    \n[49] distributional_0.4.0 stringi_1.8.3        gtable_0.3.4        \n[52] QuickJSR_1.1.3       munsell_0.5.1        pillar_1.9.0        \n[55] htmltools_0.5.7      Brobdingnag_1.2-9    R6_2.5.1            \n[58] RcppEigen_0.3.4.0.0  evaluate_0.23        lattice_0.22-5      \n[61] backports_1.4.1      renv_1.0.5           rstantools_2.4.0    \n[64] coda_0.19-4.1        gridExtra_2.3        nlme_3.1-164        \n[67] checkmate_2.3.1      mgcv_1.9-1           xfun_0.42           \n[70] pkgconfig_2.0.3     \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}