{
  "hash": "61a7b3566ab3feb45e40aea223d7fdaa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Step-function selection models for meta-analysis\ndate: '2024-06-18'\ndraft: true\n---\n\n```{ojs}\nimport {html} from \"@observablehq/htl\"\n\nlist = arr => html`<ul>\n  ${arr.map(v => html.fragment`<li>${v}</li>`)}\n</ul>`\n\ndefaultInput = v => html`<input type=\"range\" min=\"0\" max=\"1\" step = \".005\" value=${v} />`\n\nlistInput = ({\n  input = defaultInput,\n  min = 0,\n  max = 0,\n  value = null,\n  defaultValue = '',\n} = {}) => {\n  // This is a state variable that we will change as events occur on the input\n  let values = value !== null ? value : new Array(Math.max(min, 1)).fill(defaultValue)\n  \n  // Templates\n  const inputRow = (v, i) => html.fragment`<tr>\n    <td onchange=${e => changeValueAt(i, e.target.value)}>${input(v, i, values)}</td>\n    <td>      \n    <button onclick=${e => removeRow(i)} disabled=${values.length <= min}>&times;</button>\n</td>\n  </tr>`\n  \n  const footerRow = () => html.fragment`<tr>\n      <td></td>\n      <td>\n        <button onclick=${addRow} disabled=${values.length >= max && max !== 0}>+</button>\n      </td>\n  </tr>`\n  \n  // Rerender Helpers\n  const rerenderTbody = () => {\n    const tbody = output.querySelector('tbody')\n    tbody.innerHTML = ''\n    tbody.appendChild(html.fragment`${values.map(inputRow)}`)\n  }\n  \n  const rerenderTfoot = () => {\n    const tfoot = output.querySelector('tfoot')\n    tfoot.innerHTML = ''\n    tfoot.appendChild(footerRow())    \n  }\n  \n  const rerender = () => {\n    rerenderTbody()\n    rerenderTfoot()\n  }\n\n  // Event Dispatcher\n  const dispatchInputEvent = () => {\n    output.value = values\n    output.dispatchEvent(new CustomEvent('input'))\n  }\n  \n  // Event Handlers\n  const addRow = () => {\n    values.push(defaultValue)\n    rerender()\n    dispatchInputEvent()\n  }\n  \n  const removeRow = removeIdx => {\n    values = values.filter((_, i) => i !== removeIdx)\n    rerender()\n    dispatchInputEvent()\n  }\n  \n  const changeValueAt = (i, value) => {\n    values[i] = value\n    rerender()\n    dispatchInputEvent()\n  }\n  \n  const output = html`<table style=${{ width: 'auto' }}>\n    <tbody>\n      ${values.map(inputRow)}\n    </tbody>\n    <tfoot>\n      ${footerRow()}\n    </tfoot>\n  </table>`\n  \n  output.value = values\n  return output\n}\n\n```\n\n```{=html}\n<div class=\"slider-container\">\n    <div class=\"slider-track\"></div>\n    <div class=\"slider-pointer\" data-value=\"50\" style=\"left: 50%;\"></div>\n    <div class=\"slider-pointer\" data-value=\"90\" style=\"left: 90%;\"></div>\n    <div class=\"slider-pointer\" data-value=\"100\" style=\"left: 100%;\"></div>\n</div>\n```\n\n::: {.cell}\n\n```{.r .cell-code}\npwnormal <- function(mu, tau, sigma, alpha, lambda) {\n  eta <- sqrt(tau^2 + sigma^2)\n  H <- length(alpha)\n  alpha_f <- c(0, alpha, 1)\n  lambda_f <- c(1, lambda)\n  c_h <- (sigma * qnorm(1 - alpha_f) - mu) / eta\n  B_h <- pnorm(c_h[-(H+2)]) - pnorm(c_h[-1])\n  A <- sum(B_h * lambda_f)\n  pr_h <- B_h * lambda_f / A\n  function(x) {\n    x_interval <- cut(x, breaks = sigma * qnorm(1 - alpha_f), include.lowest = TRUE)\n    wt <- rev(lambda_f)[x_interval]\n    gen_prob <- dnorm((x - mu) / eta) / eta\n    wt * gen_prob / A\n  }\n}\n```\n:::\n\n```{ojs}\nmath = require(\"mathjs\")\nnorm = import('https://unpkg.com/norm-dist@3.1.0/index.js?module')\n\nlambda = Array(H+1).fill(1)\n\neta = math.sqrt(tau**2 + sigma**2)\n\n```\n\n\n:::: {.grid .column-page-inset}\n\n::: {.g-col-7}\n\n:::\n\n::: {.g-col-5}\n\n\n```{ojs}\n//| panel: input\n\nviewof alphas = listInput({\n  min: 1,\n  max: 10,\n  value: [.025,.500],\n  defaultValue: .500,\n})\n\n\nviewof H = Inputs.range(\n  [1, 10], \n  {value: 1, step: 1, label: \"Number of thresholds (H):\"}\n)\n\nviewof mu = Inputs.range(\n  [-2, 2], \n  {value: 0, step: 0.01, label: \"Average effect size (mu):\"}\n)\n\nviewof tau = Inputs.range(\n  [0, 2], \n  {value: 0.10, step: 0.01, label: \"Heterogeneity SD (tau):\"}\n)\n\nviewof sigma = Inputs.range(\n  [0, 1], \n  {value: 0.10, step: 0.01, label: \"Standard error (sigma):\"}\n)\n\n```\n\n:::\n\n::::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}