{
  "hash": "786fcab5f7067f00daaea0faeadbe37e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: A quirk of `nlme::varIdent`\ndate: '2024-12-28'\ncategories:\n- Rstats\n- programming\n- hierarchical models\n- nlme\ntoc: true\ncode-tools: true\ncode-fold: false\nreference-location: margin\ndescription: Wherein I document how to control the reference level in models that use `nlme::varIdent()` for specifying a variance structure.\n---\n\n\nThe `nlme` package is a venerable, now quite old package for fitting hierarchical models in R. \nCompared to the better-known `lme4` package, `nlme` provides greater flexibility for specifying dependence structures at the finest-grain level of the model, such as allowing for heteroskedastic errors or correlated errors that follow an auto-regressive structure within each higher-level unit.[^my-packages] \nDue to its quite advanced age (the first entry in the changelog is from December 23, 1999!), it is perhaps not surprising that the package has a number of what one might call quirks---odd, counter-intuitive behaviors that are unlike the behavior of other core model-fitting functions in R.\nA few of my past posts have documented [some](/posts/bug-in-nlme-getVarCov/) of [these quirks](/posts/Bug-in-nlme-with-fixed-sigma/). \nHere's another one.\n\n[^my-packages]: `nlme` is a minor obsession for me because Several packages that I've worked on provide formal enhancements to or are at least very closely connected to it. The [`clubSandwich` package](/software/clubSandwich/) provides cluster-robust standard errors for fitted models, and it supports models fitted with `nlme::lme()` and `nlme::gls()`. The [`lmeInfo` package](/software/lmeInfo/) provides analytic derivatives for models fitted with `nlme::lme()` and `nlme::gls()`. The [`scdhlm` package](/software/scdhlm/) for calculating effect sizes from single-case designs relies heavily on `nlme::lme()` and on `lmeInfo::g_mlm()`.\n\n### varIdent()\n\nIn `nlme`'s syntax, `varIdent()` is used to specify a model in which the variance of the lowest-level error term differs depending on a categorical covariate. I'll call this a \"heteroskedastic error\" model. Say that we have repeated measures (indexed by $h$) nested within units (indexed by $i$), so that $y_{hi}$ is measurement $h$ on unit $i$ for $h = 1,...,H_i$ and $i=1,...,N$. Let $c_{hi} \\in \\{1,...,C\\}$ denote the category of observation $hi$, and suppose that the last category serves as a reference level. Say we have some model with predictors $\\mathbf{x}_{hi}$ and potentially also with random effects terms described by $\\mathbf{z}_{hi}$:\n$$\ny_{hi} = \\mathbf{x}_{hi} \\boldsymbol\\beta + \\mathbf{z}_{hi} \\mathbf{u}_i + e_{hi}\n$$\nwhere \n$$\n\\text{Var}(e_{hi}) = \\sigma^2 \\times \\exp\\left( \\sum_{j=1}^{C-1} \\lambda_j I(c_{hi} = j)\\right).\n$$\nThe coefficients $\\lambda_1,...,\\lambda_{C-1}$ capture how the variance of errors in category $j$ differ from the variance of errors in category $C$. \nThe question is, how can one control the reference level (i.e., choose which category is $C$) when fitting this model?\n\nLet me give a few examples of models with this feature using `Orthodont`, one of the standard datasets included in the `nlme` package. Below I do a bit of tidying up on the factors in this dataset.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nlme)\ndata(\"Orthodont\")\n\nOrthodont <- \n  Orthodont %>%\n  as.data.frame() %>%\n  mutate(\n    age = as.integer(age),\n    Subject = factor(Subject, levels = sort(levels(Subject)), ordered = FALSE),\n    Sex_rev = fct_rev(Sex),\n    Sex3 = factor(if_else(\n      Subject %in% c(\"M11\",\"M12\",\"M13\",\"M14\",\"M15\",\"M16\"),\n      \"Non-binary\", \n      Sex), levels = c(\"Female\",\"Male\",\"Non-binary\")\n    )\n  )\n```\n:::\n\nHere is a simple example of a heteroskedastic error model, without any random effects or any other bells or whistles.\n\n::: {.cell}\n\n```{.r .cell-code}\ngls1 <- gls(\n  distance ~ age + Sex, \n  weights = varIdent(form = ~ 1 | Sex),\n  data = Orthodont\n)\nsummary(gls1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGeneralized least squares fit by REML\n  Model: distance ~ age + Sex \n  Data: Orthodont \n       AIC      BIC    logLik\n  494.3251 507.5949 -242.1626\n\nVariance function:\n Structure: Different standard deviations per stratum\n Formula: ~1 | Sex \n Parameter estimates:\n     Male    Female \n1.0000000 0.9378976 \n\nCoefficients:\n                Value Std.Error   t-value p-value\n(Intercept) 17.811621 1.1119255 16.018718       0\nage          0.650648 0.0975569  6.669421       0\nSexFemale   -2.321023 0.4396048 -5.279794       0\n\n Correlation: \n          (Intr) age   \nage       -0.965       \nSexFemale -0.173  0.000\n\nStandardized residuals:\n        Min          Q1         Med          Q3         Max \n-2.58304984 -0.65117352 -0.02923653  0.51805238  2.30992386 \n\nResidual standard error: 2.329342 \nDegrees of freedom: 108 total; 105 residual\n```\n\n\n:::\n:::\n\nThe reference level of the variance structure is `Male`.[^helper-function]\n\n[^helper-function]: For ease of exposition, let me make a little helper function that pulls out the reference level of the variance structure.\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    ref_level <- function(mod) {\n      attr(mod$modelStruct$varStruct, \"groupNames\")[1]\n    }\n    ref_level(gls1)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"Male\"\n    ```\n    \n    \n    :::\n    :::\n\n\n\nHere's another `gls` model, this time allowing the errors to be correlated within subject:\n\n::: {.cell}\n\n```{.r .cell-code}\ngls2 <- update(\n  gls1, \n  correlation = corCompSymm(form = ~ 1 | Subject)\n)\nref_level(gls2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\nThe reference category has now changed to Female. The same thing happens if I fit a heteroskedastic error model using `lme()`:\n\n::: {.cell}\n\n```{.r .cell-code}\nlme1 <- lme(\n  distance ~ age + Sex, \n  random = ~ 1 | Subject, \n  weights = varIdent(form = ~ 1 | Sex),\n  data = Orthodont\n)\nref_level(lme1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\nIt would be nice to be able to control the reference level.[^prior-question]\n\n[^prior-question]: I'm not the only one seeking to do this. Someone on the R-SIG-mixed-models listserv [had the same query](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2013q3/020572.html) in July of 2013, but none of the responses provide a solution.\n\n\n### What doesn't work \n\nThe usual way that one would specify reference levels is to set a contrast for the factor:\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrasts(Orthodont$Sex) <- contr.treatment(2, base = 1)\n```\n:::\n\nBut this does not seem to have any effect on the selected reference level of the variance structures:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(gls1, data = Orthodont) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(gls2, data = Orthodont) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(lme1, data = Orthodont) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\nNor does using a factor with the levels in reverse order:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(gls1, weights = varIdent(form = ~ 1 | Sex_rev)) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(gls2, weights = varIdent(form = ~ 1 | Sex_rev)) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(lme1, weights = varIdent(form = ~ 1 | Sex_rev)) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\nEmma Knight [suggested on R-SIG-mixed-models](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2013q3/020587.html) that the reference level is selected based on the category with the largest number of observations (which is `Male`). That could be what determines the reference level in `gls1` (though it clearly can't be so for `gls2` or `lme`). I've created another factor called `Sex3` where the largest category is Female. If this theory is true, then the reference level of `gls1` should change to Female:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(gls1, weights = varIdent(form = ~ 1 | Sex3)) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n:::\n\nNothing changes with the other models either:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(gls2, weights = varIdent(form = ~ 1 | Sex3)) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(lme1, weights = varIdent(form = ~ 1 | Sex3)) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\n\nWhat about the order of the data? There is [a bug report](https://bugs.r-project.org/show_bug.cgi?id=18505) documenting that `varIdent()` depends on the sort order of the categorical grouping variable when used in a `gls()` call.[^SO-question]\nSorting the data in descending order of `Sex3` does affect the reference level for `gls1`:\n\n::: {.cell}\n\n```{.r .cell-code}\nOrthodont_sort <- arrange(Orthodont, Sex3)\nOrthodont_rev <- arrange(Orthodont, desc(Sex3))\nhead(Orthodont_sort$Sex, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Female Female Female Female\nattr(,\"contrasts\")\n       2\nMale   0\nFemale 1\nLevels: Male Female\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(Orthodont_rev$Sex3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Non-binary Non-binary Non-binary Non-binary\nLevels: Female Male Non-binary\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls1, \n  data = Orthodont_sort\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls1, \n  weights = varIdent(form = ~ 1 | Sex3),\n  data = Orthodont_rev\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Non-binary\"\n```\n\n\n:::\n:::\n\nHowever, this doesn't seem to affect `gls2` or `lme1` at all:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  data = Orthodont_sort\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  weights = varIdent(form = ~ 1 | Sex3), \n  data = Orthodont_rev\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  lme1, \n  data = Orthodont_sort\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  lme1, \n  weights = varIdent(form = ~ 1 | Sex3), \n  data = Orthodont_rev\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\nVery curious.\n\n[^SO-question]: This [StackOverflow question](https://stackoverflow.com/questions/75929847/reference-category-in-varident-function-nlme-package-depends-on-data-order) notes the same issue and links to a patch from [Ben Bolker](https://math.mcmaster.ca/~bolker/). \n\n### How to control the reference level\n\nI [posted about this issue](https://stat.ethz.ch/pipermail/r-sig-mixed-models/2024q4/030737.html) to R-SIG-mixed-models with some of the above notes. [Sebastian Meyer](https://www.imbe.med.fau.de/lehrstuhl/sebastian-meyer/#collapse_0) provided a very helpful response, noting that \n\n> `lme()` internally reorders the data by the grouping factor(s) before initialization, so the order of that factor ('Subject' in your example...) will indirectly determine the reference level of varIdent(), regardless of how your data or strata levels are ordered originally.\n\nSimilar re-ordering behavior occurs in `gls()` when the model includes a grouping structure, as it does in `gls2` because of the `corCompSymm()` correlation structure. \nThis insight provides a key for controlling the reference level:\nfor a given categorical variable, the reference level will be taken as the level of the first observation in the first level of the grouping factor. \nThus, for models with grouping structure, one can set the reference level to Male by re-ordering the levels of `Subject` so that a unit with `Sex = 'Male'` occurs first.\n\n::: {.cell}\n\n```{.r .cell-code}\nOrthodont$Subject2 <- fct_relevel(Orthodont$Subject, \"M01\")\ntable(Orthodont$Subject2) |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nM01 F01 F02 F03 F04 F05 \n  4   4   4   4   4   4 \n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  correlation = corCompSymm(form = ~ 1 | Subject2)\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  lme1, \n  random = ~ 1 | Subject2\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n:::\n\nFor models without grouping structure, the reference level is indeed controlled by sort order, as if there were only a single group. \nTo control the reference level, one would need to sort the data accordingly. \nFor example, to make Female the reference level in `gls1`, the first observation in the data needs to have `Sex = 'Female'`. \nThis is so in `Orthodont_sort`:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(gls1, data = Orthodont_sort) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\n\nWhat if the categorical variable varies within the grouping factor? For instance, say that we want to fit a model with heteroskedastic errors varying by age of the subject, which varies from 8 to 14 across the repeated measures of each participant. Here's a basic heteroskedastic error `gls()`:\n\n::: {.cell}\n\n```{.r .cell-code}\ngls3 <- gls(\n  distance ~ age + Sex, \n  weights = varIdent(form = ~ 1 | age),\n  data = Orthodont\n)\n```\n:::\n\nAnd here is one with a correlation structure:\n\n::: {.cell}\n\n```{.r .cell-code}\ngls4 <- update(\n  gls3, \n  correlation = corCompSymm(form = ~ 1 | Subject)\n)\n```\n:::\n\nIn both cases, the reference level is the youngest age:\n\n::: {.cell}\n\n```{.r .cell-code}\nc(ref_level(gls3), ref_level(gls4))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"8\" \"8\"\n```\n\n\n:::\n:::\n\nTo set this to something else in the first model, just re-arrange the first few rows:\n\n::: {.cell}\n\n```{.r .cell-code}\nOrthodont2 <- Orthodont[c(4,1,2,3,5:108),]\n\nupdate(\n  gls3, \n  data = Orthodont2\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"14\"\n```\n\n\n:::\n:::\n\nHowever, this doesn't work for `gls4`[^fails-for-gls4] because the first level of the grouping factor is not the first one to appear in the data.[^grouping-order]\nBut we could sort the data by the grouping factor and then by `age` so that the desired reference level appears first:\n\n::: {.cell}\n\n```{.r .cell-code}\nOrthodont2_sort <- \n  Orthodont %>%\n  arrange(Subject, desc(age))\n\nhead(Orthodont2_sort)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   distance age Subject    Sex Sex_rev   Sex3 Subject2\n68     23.0  14     F01 Female  Female Female      F01\n67     21.5  12     F01 Female  Female Female      F01\n66     20.0  10     F01 Female  Female Female      F01\n65     21.0   8     F01 Female  Female Female      F01\n72     25.5  14     F02 Female  Female Female      F02\n71     24.0  12     F02 Female  Female Female      F02\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(gls4, data = Orthodont2_sort) |> ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"14\"\n```\n\n\n:::\n:::\n\n\n[^fails-for-gls4]: See\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    update(gls4, data = Orthodont2) |> ref_level()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"8\"\n    ```\n    \n    \n    :::\n    :::\n\n\n[^grouping-order]: The first level of `Subject` corresponds to rows 65 through 68:\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    which(levels(Orthodont2$Subject)[1] == Orthodont2$Subject)  \n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] 65 66 67 68\n    ```\n    \n    \n    :::\n    :::\n\nIt's not elegant, nor particularly intuitive, but it seems to work. \n\n### Setting a `value`\n\nSebastian also suggested another technique for directly controlling the reference level of the variance structure:\n\n> It seems that only if there are more than two strata, the reference level for varIdent() can be chosen via a named initial parameter 'value', leaving out the desired reference level, but I haven't tested if this works as intended with both gls() and lme().  It would then make sense to support such a choice also in the case of only two strata, so for a single parameter.\n\nSetting the argument `value` of `varIdent()` specifies initialization values for the variance structure. Sebastian's suggestion is to specify values for every level of the categorical variable except for the desired reference level. Let me give this a try with the `Sex3` variable, which has three distinct levels.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngls_M <- update(\n  gls1, \n  weights = varIdent(form = ~ 1 | Sex3)\n)\n\ngls_F <- update(\n  gls1, \n  weights = varIdent(\n    value = c(`Non-binary` = 0.01, Male = 0.01), \n    form = ~ 1 | Sex3\n  )\n)\n\ngls_NB <- update(\n  gls1, \n  weights = varIdent(\n    value = c(Female = 0.01, Male = 0.01), \n    form = ~ 1 | Sex3\n  )\n)\n\ncoef(gls_M$modelStruct$varStruct, unconstrained = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNon-binary     Female \n 0.7438755  0.8608531 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(gls_F$modelStruct$varStruct, unconstrained = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNon-binary       Male \n  0.864114   1.161639 \n```\n\n\n:::\n\n```{.r .cell-code}\ncoef(gls_NB$modelStruct$varStruct, unconstrained = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Female     Male \n1.157254 1.344311 \n```\n\n\n:::\n:::\n\nIndeed, this works for models with variance structures but no correlation structures or random effects.\nLikewise for `gls` models that include grouping structure:\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  weights = varIdent(form = ~ 1 | Sex3)\n) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  weights = varIdent(\n    value = c(`Non-binary` = 0.01, Female = 0.01), \n    form = ~ 1 | Sex3\n  )\n) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  weights = varIdent(\n    value = c(Female = 0.01, Male = 0.01), \n    form = ~ 1 | Sex3\n  )\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Non-binary\"\n```\n\n\n:::\n:::\n\n\nAnd for `lme` models with random effects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(lme1, weights = varIdent(form = ~ 1 | Sex3)) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  lme1, \n  weights = varIdent(\n    value = c(`Non-binary` = 0.01, Female = 0.01), \n    form = ~ 1 | Sex3\n  )\n) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  lme1, \n  weights = varIdent(\n    value = c(Female = 0.01, Male = 0.01), \n    form = ~ 1 | Sex3\n  )\n) |> \n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Non-binary\"\n```\n\n\n:::\n:::\n\nHowever, as Sebastian noted, it does not work for categories with only two levels (so only one non-reference level):\n\n::: {.cell}\n\n```{.r .cell-code}\nupdate(\n  gls1, \n  weights = varIdent(\n    value = c(Male = 0.01), \n    form = ~ 1 | Sex\n  )\n) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Male\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  gls2, \n  weights = varIdent(\n    value = c(Female = 0.01), \n    form = ~ 1 | Sex\n  )\n) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n\n```{.r .cell-code}\nupdate(\n  lme1, \n  weights = varIdent(\n    value = c(Female = 0.01), \n    form = ~ 1 | Sex\n  )\n) |>\n  ref_level()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Female\"\n```\n\n\n:::\n:::\n\nThus, this is only a partial solution. I agree with Sebastian that it would be useful to support user-specified levels within the `value` argument, even for factors with just one non-reference level.\n\n### Colophon\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.1 (2024-06-14 ucrt)\n os       Windows 11 x64 (build 22631)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Chicago\n date     2024-12-28\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n P cli           3.6.3   2024-06-21 [?] RSPM\n P colorspace    2.1-1   2024-07-26 [?] RSPM\n P digest        0.6.37  2024-08-19 [?] RSPM (R 4.4.0)\n P dplyr       * 1.1.4   2023-11-17 [?] RSPM\n P evaluate      0.23    2023-11-01 [?] RSPM (R 4.4.0)\n P fansi         1.0.6   2023-12-08 [?] RSPM\n P fastmap       1.1.1   2023-02-24 [?] RSPM (R 4.4.0)\n P forcats     * 1.0.0   2023-01-29 [?] RSPM\n P generics      0.1.3   2022-07-05 [?] RSPM\n P ggplot2     * 3.5.1   2024-04-23 [?] RSPM\n P glue          1.8.0   2024-09-30 [?] RSPM (R 4.4.0)\n P gtable        0.3.6   2024-10-25 [?] RSPM (R 4.4.0)\n P hms           1.1.3   2023-03-21 [?] RSPM\n P htmltools     0.5.7   2023-11-03 [?] RSPM (R 4.4.1)\n P htmlwidgets   1.6.4   2023-12-06 [?] RSPM\n P jsonlite      1.8.8   2023-12-04 [?] RSPM\n P knitr         1.47    2024-05-29 [?] RSPM (R 4.4.0)\n P lattice       0.22-5  2023-10-24 [?] RSPM (R 4.4.1)\n P lifecycle     1.0.4   2023-11-07 [?] RSPM\n P lubridate   * 1.9.3   2023-09-27 [?] RSPM\n P magrittr      2.0.3   2022-03-30 [?] RSPM\n P munsell       0.5.1   2024-04-01 [?] RSPM\n P nlme        * 3.1-166 2024-08-14 [?] RSPM\n P pillar        1.9.0   2023-03-22 [?] RSPM\n P pkgconfig     2.0.3   2019-09-22 [?] RSPM\n P purrr       * 1.0.2   2023-08-10 [?] RSPM\n P R6            2.5.1   2021-08-19 [?] RSPM\n P readr       * 2.1.5   2024-01-10 [?] RSPM\n   renv          1.0.5   2024-02-29 [1] RSPM (R 4.4.0)\n P rlang         1.1.4   2024-06-04 [?] RSPM\n P rmarkdown     2.27    2024-05-17 [?] RSPM\n P rstudioapi    0.17.1  2024-10-22 [?] RSPM (R 4.4.0)\n P scales        1.3.0   2023-11-28 [?] RSPM\n P sessioninfo   1.2.2   2021-12-06 [?] RSPM (R 4.4.0)\n P stringi       1.8.4   2024-05-06 [?] RSPM\n P stringr     * 1.5.1   2023-11-14 [?] RSPM\n P tibble      * 3.2.1   2023-03-20 [?] RSPM\n P tidyr       * 1.3.1   2024-01-24 [?] RSPM\n P tidyselect    1.2.1   2024-03-11 [?] RSPM\n P tidyverse   * 2.0.0   2023-02-22 [?] RSPM\n P timechange    0.3.0   2024-01-18 [?] RSPM\n P tzdb          0.4.0   2023-05-12 [?] RSPM\n P utf8          1.2.4   2023-10-22 [?] RSPM\n P vctrs         0.6.5   2023-12-01 [?] RSPM\n   withr         3.0.2   2024-10-28 [1] RSPM (R 4.4.0)\n P xfun          0.45    2024-06-16 [?] RSPM (R 4.4.0)\n P yaml          2.3.8   2023-12-11 [?] RSPM (R 4.4.0)\n\n [1] C:/Users/jamespustejovsky/Documents/jepusto-quarto/renv/library/R-4.4/x86_64-w64-mingw32\n [2] C:/Users/jamespustejovsky/AppData/Local/R/cache/R/renv/sandbox/R-4.4/x86_64-w64-mingw32/e0da0d43\n\n P ── Loaded and on-disk path mismatch.\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}