{
  "hash": "ce350704519dbb43279f5a2a6544b6a1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: A meta-sandwich\nauthors: admin\ndate: '2014-04-21'\ncategories:\n- meta-analysis\n- sandwiches\n- Rstats\n- robust variance estimation\ncode-tools: true\n\n---\n\n\nA common problem arising in many areas of meta-analysis is how to synthesize a set of effect sizes when the set includes multiple effect size estimates from the same study. It's often not possible to obtain all of the information you'd need in order to estimate the sampling covariances between those effect sizes, yet without that information, established approaches to modeling dependent effect sizes become inaccurate. [Hedges, Tipton, & Johnson](http://doi.org/10.1002/jrsm.5) (2010, HTJ hereafter) proposed the use of cluster-robust  standard errors for multi-variate meta-analysis. (These are also called \"sandwich\" standard errors, which is up there on the list of great and evocative names for statistical procedures.) The great advantage of the sandwich approach is that it permits valid inferences for average effect sizes and meta-regression coefficients even if you don't have correct covariance estimates (or variance estimates, for that matter).\n\nI recently heard from [Beth Tipton](http://blogs.cuit.columbia.edu/let2119/) (who's a graduate-school buddy) that she and her student have written an [R package](http://cran.r-project.org/web/packages/robumeta/index.html) implementing the HTJ methods, including moment estimators for the between-study variance components. I want to try out the cluster-robust standard errors for a project I'm working on, but I also need to use REML estimators rather than the moment estimators. It turns out, it's easy enough to do that by writing a couple of short functions. Here's how.\n\nFirst, the [metafor package](http://cran.r-project.org/web/packages/metafor/index.html) contains a very rich suite of meta-analytic methods, including for multi-variate meta-analysis. The only thing it lacks is sandwich standard errors. However, the [sandwich package](http://cran.r-project.org/web/packages/sandwich/index.html) provides an efficient, well-structured framework for calculating all sorts of robust standard errors. All that's needed are a few functions to make the packages talk to each other. Each of the functions described below takes as input a fitted multi-variate meta-analysis model, which is represented in R by an object of class `rma.mv`.\n\nFirst load up the packages:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(metafor)\nlibrary(sandwich)\nlibrary(lmtest)\n```\n:::\n\n\nNext, I need a `bread` method for objects of class `rma.mv`, which is a function that returns the $p \\times p$ matrix $\\displaystyle{m \\left(\\sum_{i=1}^m \\mathbf{X}_j' \\mathbf{W}_j \\mathbf{X}_j\\right)^{-1}}$. The bread function is straight-forward because it is just a multiple of the model-based covariance matrix, which `rma.mv` objects store in the `vb` component:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbread.rma.mv <- function(obj) {\n  cluster <- findCluster(obj)\n  length(unique(cluster)) * obj$vb  \n}\n```\n:::\n\n\nI also need an `estfun` method for objects of class `rma.mv`, which is a function that returns an $m \\times p$ matrix where row $j$ is equal to $\\mathbf{e}_j' \\mathbf{W}_j \\mathbf{X}_j$, $j = 1,...,m$. The necessary pieces for the `estfun` method can also be pulled out of the components of `rma.mv`:\n\n::: {.cell}\n\n```{.r .cell-code}\nestfun.rma.mv <- function(obj) {\n  cluster <- droplevels(as.factor(findCluster(obj)))\n  res <- residuals(obj)\n  WX <- chol2inv(chol(obj$M)) %*% obj$X\n  rval <- by(cbind(res, WX), cluster, \n             function(x) colSums(x[,1] * x[,-1, drop = FALSE]))\n  rval <- matrix(unlist(rval), length(unique(cluster)), obj$p, byrow=TRUE)\n  colnames(rval) <- colnames(obj$X)\n  rval\n}\n```\n:::\n\n\nThe remaining question is how to determine which of the components in the model should be used to define independent clusters. This is a little bit tricky because there are several different methods of specifying random effects in the `rma.mv` function. One way involves providing a list of formulas, each containing a factor associated with a unique random effect, such as `random = list( ~ 1 | classroom, ~ 1 | school)`. If this method of specifying random effects is used, the `rma.mv` object will have the component `withS` set to `TRUE`, and my approach is to simply take the factor with the smallest number of unique levels. This is perhaps a little bit presumptious, because the `withS` method could potentially be used to specify arbitrary random effects, where one level is not strictly nested inside another. However, probably the most common use will involve nested factors, so my assumption seems like a good starting point at least.\n\nAnother approach to specifying random effects is to use a formula of the form `random = inner | outer`, in which case the `rma.mv` object will have the component `withG` set to `TRUE`. Here, it seems reasonable to use the `outer` factor for defining clusters. If both the `withS` and `withG` methods are used together, I'll assume that the `withS` factors contain the outermost level. \n\nFinally, if `rma.mv` is used to estimate a fixed effects model without any random components, the clustering factor will have to be manually added to the `rma.mv` object in a component called `cluster`. For example, if you want to cluster on the variable `studyID` in the dataframe `dat`: \n\n::: {.cell}\n\n```{.r .cell-code}\nrma_fit$cluster <- dat$studyID\n```\n:::\n\n\nHere's code that implements these assumptions:\n\n::: {.cell}\n\n```{.r .cell-code}\nfindCluster <- function(obj) {\n  if (is.null(obj$cluster)) {\n    if (obj$withS) {\n      r <- which.min(obj$s.nlevels)\n      cluster <- obj$mf.r[[r]][[obj$s.names[r]]]\n    } else if (obj$withG) {\n      cluster <- obj$mf.r[[1]][[obj$g.names[2]]]\n    } else {\n        stop(\"No clustering variable specified.\")\n    }\n  } else {\n    cluster <- obj$cluster\n  }\n  cluster\n}\n```\n:::\n\n\nWith these three functions, you can then use `metafor` to fit a random effects model, `sandwich` to calculate the standard errors, and functions like `coeftest` from the package `lmtest` to run $t$-tests. As a little bonus, here's a function for probably the most common case of how you'd use the sandwich standard errors:\n\n::: {.cell}\n\n```{.r .cell-code}\nRobustResults <- function(obj, adjust = TRUE) {\n  cluster <- findCluster(obj)  \n  vcov. <- sandwich(obj, adjust = adjust)\n  df. <- length(unique(cluster)) - obj$p\n  coeftest(obj, vcov. = vcov., df = df.)\n}\n```\n:::\n\n\n[See here](https://gist.github.com/jepusto/11144005) for a file containing the full code.\n\n### Example\n\n[Tanner-Smith & Tipton (2013)](http://doi.org/10.1002/jrsm.1091) provide an application of the cluster-robust method to a fictional dataset with 68 effect sizes nested within 15 studies. They call this a \"hierarchical\" dependence example because each effect size estimate is drawn from an independent sample, but dependence is induced because the experiments were all done in the same lab. For comparison purposes, here are the results produced by `robumeta`:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(grid)\nlibrary(robumeta)\ndata(hierdat)\n\nHTJ <- robu(effectsize ~ 1,\n       data = hierdat, modelweights = \"HIER\",\n       studynum = studyid,\n       var.eff.size = var, small = FALSE)\nHTJ\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRVE: Hierarchical Effects Model  \n\nModel: effectsize ~ 1 \n\nNumber of clusters = 15 \nNumber of outcomes = 68 (min = 1 , mean = 4.53 , median = 2 , max = 29 )\nOmega.sq = 0.1560802 \nTau.sq = 0.06835547 \n\n               Estimate StdErr t-value dfs  P(|t|>) 95% CI.L 95% CI.U Sig\n1 X.Intercept.     0.25 0.0598    4.18  14 0.000925    0.122    0.378 ***\n---\nSignif. codes: < .01 *** < .05 ** < .10 *\n---\n```\n\n\n:::\n:::\n\n\nTo exactly re-produce the results with `metafor`, I'll need to use the weights proposed by HTJ. In their approach, effect size $i$ from study $j$ receives weight equal to $\\left(v_{ij} + \\hat\\omega^2 + \\hat\\tau^2\\right)^{-1}$, where $v_{ij}$ is the sampling variance of the effect size, $\\hat\\omega^2$ is an estimate of the between-sample within-study variance, and $\\hat\\tau^2$ is an estimate of the between-study variance. After calculating these weights, I fit the model in metafor, calculate the sandwich covariance matrix, and replay the results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhierdat$var_HTJ <- hierdat$var + HTJ$mod_info$omega.sq + HTJ$mod_info$tau.sq # calculate weights\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in hierdat$var + HTJ$mod_info$omega.sq: Recycling array of length 1 in vector-array arithmetic is deprecated.\n  Use c() or as.vector() instead.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in hierdat$var + HTJ$mod_info$omega.sq + HTJ$mod_info$tau.sq: Recycling array of length 1 in vector-array arithmetic is deprecated.\n  Use c() or as.vector() instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nmeta1 <- rma.mv(yi = effectsize ~ 1, V = var_HTJ, data = hierdat, method = \"FE\")\nmeta1$cluster <- hierdat$studyid # add clustering variable to the fitted model\nRobustResults(meta1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nt test of coefficients:\n\n        Estimate Std. Error t value  Pr(>|t|)    \nintrcpt 0.249826   0.059762  4.1803 0.0009253 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\nThe HTJ weights are not the only alternative--one could instead use weights that are exactly inverse variance under the posited model. For effect $i$ from study $j$, these weights would be closer to $\\left(v_{ij} + \\hat\\omega^2 + k_j \\hat\\tau^2 \\right)^{-1}$. For $\\hat\\tau^2 > 0$, the inverse-variance weights put proportionately less weight on studies containing many effects. These weights can be calculated in `metafor` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeta2 <- rma.mv(yi = effectsize ~ 1, V = var, \n                 random = list(~ 1 | esid, ~ 1 | studyid), \n                 sigma2 = c(HTJ$mod_info$omega.sq, HTJ$mod_info$tau.sq),\n                 data = hierdat)\nRobustResults(meta2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nt test of coefficients:\n\n        Estimate Std. Error t value Pr(>|t|)   \nintrcpt 0.264422   0.086688  3.0503 0.008645 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\nCuriously, the robust standard error increases under a weighting scheme that is more efficient if the model is correct. \n\nFinally, `metafor` provides ML and REML estimators for the between-sample and between-study random effects (the HTJ moment estimators are not available though). Here are the results based on REML estimators and the corresponding inverse-variance weights:\n\n::: {.cell}\n\n```{.r .cell-code}\nmeta3 <- rma.mv(yi = effectsize ~ 1, V = var, \n                 random = list(~ 1 | esid, ~ 1 | studyid), \n                 data = hierdat,\n                method = \"REML\")\nmeta3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nMultivariate Meta-Analysis Model (k = 68; method: REML)\n\nVariance Components:\n\n            estim    sqrt  nlvls  fixed   factor \nsigma^2.1  0.2263  0.4757     68     no     esid \nsigma^2.2  0.0000  0.0000     15     no  studyid \n\nTest for Heterogeneity:\nQ(df = 67) = 370.1948, p-val < .0001\n\nModel Results:\n\nestimate      se    zval    pval   ci.lb   ci.ub      \n  0.2501  0.0661  3.7822  0.0002  0.1205  0.3797  *** \n\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n\n```{.r .cell-code}\nRobustResults(meta3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nt test of coefficients:\n\n        Estimate Std. Error t value  Pr(>|t|)    \nintrcpt 0.250071   0.059796  4.1821 0.0009222 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\nThe between-study variance estimate is tiny, particularly when compared to the between-sample within-study estimate. Despite the difference in variance estimates, the average effect size estimate is nearly identical to the estimate based on the HTJ approach.\n\n[See here](https://gist.github.com/jepusto/11143798) for the full code to reproduce this example.\n\n### Notes\n\nIt would be straight-forward to add a few more functions that provide robust standard errors for univariate meta-analysis models as well. All that it would take is to write `bread` and `estfun` methods for the class `rma.uni`. \n\nAlso, Beth [has recently proposed](https://www.sree.org/conferences/2014s/program/downloads/abstracts/1089.pdf) \nsmall-sample corrections to the cluster-robust estimators, based on the bias-reduced linearization (BRL) approach of [McCaffrey, Bell, & Botts (2001)](http://www.amstat.org/sections/SRMS/Proceedings/y2001/Proceed/00264.pdf). It seems to me that these small-sample corrections could also be implemented using an approach similar to what I've done here, by building out the `estfun` method to provide BRL results. It would take a little more thought, but actually it would be worth doing--and treating the general case--because BRL seems like it would be useful for all sorts of models besides multi-variate meta-analysis.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}