{
  "hash": "92cc031e11f4816278926f3babac15fc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Bootstrap confidence interval variations\ndate: '2025-01-15'\ncategories:\n- programming\n- Rstats\n- bootstrap\ncode-fold: show\ncode-tools: true\ntoc: true\nbibliography: \"references.bib\"\ncsl: \"../apa.csl\"\n---\n\n\n\nI recently added some new utilities for calculating bootstrap confidence intervals to the [`simhelpers` package](https://meghapsimatrix.github.io/simhelpers/). \nThe functions are designed to make it a bit more convenient to implement Monte Carlo simulations of bootstrap CIs, including when using an extrapolation technique suggested by @boos2000MonteCarloEvaluation, which [I wrote about a while ago](/posts/Simulating-bootstrap-CIs/). \nWith the latest update, the package now provides options for a bunch of different variants of bootstrap CIs, including:\n\n* the normal CI, which uses bootstrapping to estimate a standard error and bias-correction, then takes plus or minus a normal critical value times the SE;\n* the studentized CI, which uses the bootstrap distribution of a t-statistic rather than the point estimator;\n* the percentile CI, which takes percentiles of the bootstrap distribution as the end-points of the CI;\n* the so-called \"basic\" CI, which is similar to the percentile CI but pivots the bootstrap distribution around the point estimator;\n* a bias-corrected version of the percentile CI;\n* Efron's [-@efron1987better] bias-corrected-and-accelerated CI, which is supposed to provide more accurate coverage levels than alternative CIs for some classes of estimators. \n\nThese CI variants are also implemented in other packages. \nMost notably, all of them are implemented in [`boot`](https://cran.r-project.org/package=boot) [@bootpkg], the venerable R package companion to the @Davison1997bootstrap book on bootstrapping.\nAlthough very full-featured and widely used (it has 377 reverse dependencies!), the `boot` package does not offer a super-friendly user experience. \nIts output is a unwieldy, there are several quirks to its naming conventions, and its function for confidence interval calculations require the user to implement the bootstrap resampling calculations through `boot::boot()`, which is sometimes a bit awkward.\nNewer packages that provide some of the same methods include [`infer`](https://infer.netlify.app/) [@Couch2021infer] and [`rsample`](https://rsample.tidymodels.org/) [@rsamplepkg].\nBoth of these offer pipe-friendly workflows, but neither provides the full slate of CI variants. \nAs with `boot`, these packages also lock in (or at least strongly nudge) the user to the package's resampling tools. \nAnd none of the packages support a workflow for the @boos2000MonteCarloEvaluation extrapolation technique. \n\nIn this post, I'll demonstrate the `simhelpers` implementation of these different CI variants with an example, compare the results to implementations in other packages, and then show how the `simhelpers` implementation can be used for the  @boos2000MonteCarloEvaluation extrapolation technique.\n\n# Bootstrap confidence intervals for a mean\n\nLet me demonstrate the confidence intervals using a simple example of estimating a correlation. For illustrative purposes, I'll use the `swiss` dataset of various socio-demographic measures of provinces in Switzerland from the late 19th century. I'll look at the correlation between level of education and a measure of fertility:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(ggplot2)\ndata(\"swiss\")\nggplot(swiss) + \n  aes(x = Education, y = Fertility) + \n  geom_point(color = \"purple\") + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=75%}\n:::\n:::\n\n\nHere is a function to calculate the sample correlation and its standard error (which is necessary for the studentized CIs):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_calc_cor <- function(x) {\n  r <- cor(x$Education, x$Fertility) \n  n <- nrow(x)\n  c(r = r, SE = sqrt((1 - r^2)^2 / (n - 1)))\n}\n\nest <- my_calc_cor(swiss)\nest\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          r          SE \n-0.66378886  0.08247672 \n```\n\n\n:::\n:::\n\n\n\nUsing this function, we can generate a sample from the bootstrap distribution of the mean:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- nrow(swiss)\ncors_boot <- replicate(999, {\n  i <- sample(1:N, replace = TRUE, size = N)\n  my_calc_cor(swiss[i,])\n}) |>\n  t() |>\n  as.data.frame()\n```\n:::\n\n\n\nThe bootstrap distribution of the sample correlations is clearly skewed and non-normal:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(cors_boot) + \n  aes(r) + \n  geom_density(fill = \"green\", alpha = 0.25) + \n  geom_vline(xintercept = est[\"r\"], color = \"green\", linewidth = 1.2) + \n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=75%}\n:::\n:::\n\n\nAs a consequence of the asymmetry and non-normality of the bootstrap distribution, the different CI variants will produce discrepant intervals.\nThe simhelpers function for calculating these intervals is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(simhelpers)\n\nbootstrap_CIs(\n  boot_est = cors_boot$r,\n  boot_se = cors_boot$SE,\n  est = est[\"r\"],\n  se = est[\"SE\"],\n  CI_type = c(\"normal\",\"basic\",\"student\",\"percentile\",\"bias-corrected\"),\n  format = \"long\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  bootstraps           type      lower      upper\n1        999         normal -0.9061176 -0.4641111\n2        999          basic -0.9571476 -0.5281576\n3        999        student -0.8539880 -0.4535804\n4        999     percentile -0.7994201 -0.3704302\n5        999 bias-corrected -0.7994201 -0.3729852\n```\n\n\n:::\n:::\n\n\nFor the bias-corrected-and-accelerated interval, the function requires the user to provide a vector of the empirical influence values of each observation. I'll calculate these using a jack-knife:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# leave-one-out jack-knife\njacks <- sapply(1:N, \\(x) my_calc_cor(swiss[-x,])[\"r\"])\n# empirical influence\ninf_vals <- mean(jacks) - jacks\n\n# Now recalculate the bootstrap CIs\nmy_boot_CIs <- bootstrap_CIs(\n  boot_est = cors_boot$r,\n  boot_se = cors_boot$SE,\n  est = est[\"r\"],\n  se = est[\"SE\"],\n  influence = inf_vals,\n  CI_type = c(\"normal\",\"basic\",\"student\",\"percentile\",\"bias-corrected\",\"BCa\"),\n  format = \"long\",\n  seed = 20250111\n)\n```\n:::\n\n\nFor sample correlation coefficients, another way to compute a confidence interval is via Fisher's z-transformation, which is both normalizing and variance-stabilizing (so that the standard error of the point estimator does not depend on the parameter) under bivariate normality. The end-points of the CI on the Fisher z scale can then be back-transformed to the original scale. Here's my \"by-hand\" calculation of this interval:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- atanh(est[\"r\"])\nSE_z <- 1 / sqrt(N - 3)\nCI_z <- z + c(-1, 1) * qnorm(0.975) * SE_z\nCI_r <- data.frame(\n  type = \"Fisher z\",\n  lower = tanh(CI_z[1]),\n  upper = tanh(CI_z[2])\n)\n\nCI_r\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      type      lower      upper\n1 Fisher z -0.7987075 -0.4653206\n```\n\n\n:::\n:::\n\n\nHow do these various CIs compare? Here's a graph illustrating all of the intervals:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nCI_r$bootstraps <- 0\nall_CIs <- rbind(my_boot_CIs, CI_r)\nall_CIs$type <- factor(all_CIs$type, levels = c(\"Fisher z\",\"BCa\",\"bias-corrected\",\"percentile\",\"basic\",\"student\",\"normal\"))\n\nggplot(all_CIs) +\n  aes(xmin = lower, xmax = upper, y = type, color = type) + \n  geom_vline(xintercept = est[\"r\"], color = \"green\", linewidth = 1.2) + \n  geom_errorbar() + \n  theme_minimal() + \n  theme(legend.position = \"none\") + \n  labs(y = \"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=75%}\n:::\n:::\n\n\nThe various bootstrap intervals differ by quite a bit. \nThe percentile and bias-corrected percentile intervals are wide and extend to smaller correlations than the other intervals. \nThe basic interval is markedly different, extending to much higher correlations than any of the other intervals. \nThe studentized and BCa intervals are closer to each other and come closer to matching the end-points of the Fisher z interval.\nIt's not necessarily the case that Fisher's z interval is correct or optimal, unless the observations actually are drawn from a bivariate normal distribution.\nBut it does seem suggestive that the studentized and BCa intervals are closer to agreeing with Fisher.\n\n# Comparison to other packages\n\n## `boot`\n\nComparing the above calculations to what can be done with other packages is useful both as a validation exercise and as an illustration of the differences in workflow. \nPerhaps the most widely known R package for bootstrapping is Canty and Ripley's [`boot`](https://cran.r-project.org/package=boot) package. \nUsing it to obtain confidence intervals for a correlation requires running the bootstrap resampling process through its `boot()` function, which takes a bit of fiddling.\nFirst, I have to revise my `calc_cor()` function to take a subsetting index and to return the sampling variance instead of the standard error:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(boot) \n\nboot_calc_cor <- function(x, i = 1:nrow(x)) {\n  r <- cor(x$Education[i], x$Fertility[i]) \n  n <- nrow(x[i,])\n  c(r = r, V = (1 - r^2)^2 / (n - 1))\n}\n```\n:::\n\n\nNow I can run it through `boot()` and compute some confidence intervals:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(20250111)\nswiss_boots <- boot(swiss, boot_calc_cor, R = 999)\nboot_boot_CIs <- boot.ci(swiss_boots, type = \"all\")\nboot_boot_CIs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 999 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = swiss_boots, type = \"all\")\n\nIntervals : \nLevel      Normal              Basic             Studentized     \n95%   (-0.8854, -0.4754 )   (-0.9211, -0.5268 )   (-0.8362, -0.4502 )  \n\nLevel     Percentile            BCa          \n95%   (-0.8008, -0.4065 )   (-0.8111, -0.4518 )  \nCalculations and Intervals on Original Scale\n```\n\n\n:::\n:::\n\n\nThe package does not have an option for bias-corrected intervals (without acceleration) but it can be hacked by feeding a symmetrically distributed vector of influence points:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_BC_CI <- boot.ci(swiss_boots, type = \"bca\", L = -1:1)\nboot_BC_CI\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\nBased on 999 bootstrap replicates\n\nCALL : \nboot.ci(boot.out = swiss_boots, type = \"bca\", L = -1:1)\n\nIntervals : \nLevel       BCa          \n95%   (-0.8027, -0.4128 )  \nCalculations and Intervals on Original Scale\n```\n\n\n:::\n:::\n\n\nThese results will not align exactly with those reported above because they're based on a different sample from the bootstrap distribution. \nTo allow for direct comparison, I'll recompute the intervals using the bootstrap sample stored in `swiss_boots` (and computing the influence values using the same method as used implicitly by `boot.ci()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemp_inf_vals <- empinf(swiss_boots)\n\nmy_boot_CIs <- bootstrap_CIs(\n  boot_est = swiss_boots$t[,1],\n  boot_se = sqrt(swiss_boots$t[,2]),\n  est = swiss_boots$t0[1],\n  se = sqrt(swiss_boots$t0[2]),\n  influence = emp_inf_vals,\n  CI_type = c(\"normal\",\"basic\",\"student\",\"percentile\",\"bias-corrected\",\"BCa\"),\n  format = \"long\"\n)\n```\n:::\n\n\nIt'd be nice to put the results from `boot.ci()` into a table to ease comparison with the output of `bootstrap_CIs()`, but its output is fairly untidy. Wrangling it takes a bit of work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_boot_CI_tab <- data.frame(\n  type = c(\"normal\",\"basic\",\"student\",\"percentile\",\"bias-corrected\",\"BCa\"),\n  boot_lower = c(\n    boot_boot_CIs$normal[2],\n    boot_boot_CIs$basic[4],\n    boot_boot_CIs$student[4],\n    boot_boot_CIs$percent[4],\n    boot_BC_CI$bca[4],\n    boot_boot_CIs$bca[4]\n  ),\n  boot_upper = c(\n    boot_boot_CIs$normal[3],\n    boot_boot_CIs$basic[5],\n    boot_boot_CIs$student[5],\n    boot_boot_CIs$percent[5],\n    boot_BC_CI$bca[5],\n    boot_boot_CIs$bca[5]\n  )\n)\n\ncbind(my_boot_CIs, boot_boot_CI_tab[,2:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  bootstraps           type      lower      upper boot_lower boot_upper\n1        999         normal -0.8854201 -0.4754233 -0.8854201 -0.4754233\n2        999          basic -0.9210706 -0.5268220 -0.9210706 -0.5268220\n3        999        student -0.8361986 -0.4502460 -0.8361986 -0.4502460\n4        999     percentile -0.8007557 -0.4065071 -0.8007557 -0.4065071\n5        999 bias-corrected -0.8017628 -0.4135041 -0.8027344 -0.4127751\n6        999            BCa -0.8110222 -0.4519353 -0.8111334 -0.4517669\n```\n\n\n:::\n:::\n\n\nThe first four intervals exactly match across packages. \nThe bias-corrected and BCa intervals differ slightly because the packages use different interpolation methods for calculating percentiles that don't correspond to integer positions in the sorted bootstrap sample. \n\n## `infer`\n\nThe [`infer`](https://infer.netlify.app/) package aims to provide a coherent grammar for statistical inference (including hypothesis testing and confidence intervals) based on resampling methods, following principles of tidy data and offering a pipe-friendly workflow. Again, I'll need to repeat the bootstrap re-sampling in the package's idiom:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(infer)\nset.seed(20250111)\n\n# Compute point estimate\ncorrelation_hat <- swiss |>\n   specify(Fertility ~ Education) |>\n   calculate(stat = \"correlation\")\n\n# Compute bootstrap distribution\ninfer_boot <- \n  swiss |>\n   specify(Fertility ~ Education) |>\n   generate(reps = 999, type = \"bootstrap\") |>\n   calculate(stat = \"correlation\")\n```\n:::\n\n\nI can then calculate studentized, percentile, and bias-corrected bootstrap CIs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nCI_normal <- get_confidence_interval(\n  infer_boot, type = \"se\", \n  point_estimate = correlation_hat, level = 0.95\n)\n\nCI_percentile <- get_confidence_interval(\n  infer_boot, type = \"percentile\", \n  level = 0.95\n)\n\nCI_biascorrected <- get_confidence_interval(\n  infer_boot, type = \"bias-corrected\", \n  point_estimate = correlation_hat, level = 0.95\n)\n\ninfer_CIs <- \n  bind_rows(\n    normal = CI_normal,\n    percentile = CI_percentile,\n    `bias-corrected` = CI_biascorrected,\n    .id = \"type\"\n  )\n```\n:::\n\n\nFor comparison purposes, I'll once again need to re-compute the intervals with `bootstrap_CIs()`, this time with the `infer` bootstrap sample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_infer_CIs <- bootstrap_CIs(\n  boot_est = infer_boot$stat,\n  est = correlation_hat$stat,\n  CI_type = c(\"normal\",\"percentile\",\"bias-corrected\"),\n  format = \"long\"\n)\n\ninner_join(my_infer_CIs, infer_CIs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  bootstraps           type      lower      upper   lower_ci   upper_ci\n1        999         normal -0.9052953 -0.4614019 -0.8857356 -0.4418421\n2        999     percentile -0.8030248 -0.3487307 -0.8027752 -0.3507277\n3        999 bias-corrected -0.8027620 -0.3487307 -0.8027066 -0.3504208\n```\n\n\n:::\n:::\n\n\nThe results do not exactly match across packages. For the normal interval, the difference occurs because the `simhelpers` implementation (like the `boot` implementation) includes a bias-correction term that shifts the interval by the difference between the point estimate and the average bootstrap estimate, which `infer` does not do.\nThe very small differences in the percentile and bias-corrected intervals are due to the use of different interpolation methods for calculating percentiles. \n\n## `rsample`\n\nOkay, one last time, this time using the [`rsample`](https://rsample.tidymodels.org/) package by @rsamplepkg. \nI'll first need to re-work my correlation calculation to provide a `data.frame` with columns called `term`, `estimate`, and `std.error`, and also ensure that the function allows for extra arguments with `...`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsample_calc_cor <- function(split, ...) {\n  x <- analysis(split)\n  n <- nrow(x)\n  r <- cor(x$Education, x$Fertility)\n  tibble(\n    term = \"corr\",\n    estimate = r,\n    std.error = sqrt((1 - r^2)^2 / (n - 1))\n  )\n}\n```\n:::\n\n\nNow I can generate a bootstrap distribution using `bootstraps`, setting `apparent = TRUE` to include calculation of the point estimate and analytical standard error. I'll use about 2000 bootstraps here to avoid an automated warning message.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(tidyr)\nlibrary(rsample)\n\nset.seed(20250111)\nrsample_boots <- \n  swiss %>%\n  bootstraps(1999, apparent = TRUE) %>%\n  mutate(r = map(splits, rsample_calc_cor))\n```\n:::\n\n\nThe `resample` package provides functions for calculating percentile, studentized, and BCa intervals. I'll do all three:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsample_CIs <- bind_rows(\n  int_pctl(rsample_boots, statistics = r),\n  int_t(rsample_boots, statistics = r),\n  int_bca(rsample_boots, statistics = r, .fn = rsample_calc_cor)\n) %>%\n  select(type = .method, .lower, .upper) %>%\n  mutate(\n    type = recode(type, `student-t` = \"student\")\n  )\n```\n:::\n\n\nNow I'll redo the interval calculations with `bootstrap_CIs()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# just the point estimate\nrsample_apparent <- \n  rsample_boots %>%\n  filter(id == \"Apparent\") %>%\n  unnest(r)\n\n# just the bootstraps\nrsample_boots <-\n  rsample_boots %>%\n  filter(id != \"Apparent\") %>%\n  unnest(r)\n\n# jack-knife to get empirical influence values\ninf_vals <- \n  swiss %>%\n  loo_cv() %>%\n  mutate(r = map(splits, rsample_calc_cor)) %>%\n  unnest(r) %>%\n  mutate(\n    inf_val = rsample_apparent$estimate - estimate\n  ) %>%\n  pull(inf_val)\n\n# calculate bootstrap CIs  \nmy_rsample_CIs <- \n  bootstrap_CIs(\n    boot_est = rsample_boots$estimate,\n    boot_se = rsample_boots$std.error,\n    est = rsample_apparent$estimate,\n    se = rsample_apparent$std.error,\n    influence = inf_vals,\n    CI_type = c(\"student\",\"percentile\",\"BCa\"),\n    format = \"long\"\n  )\n\n# Compare\ninner_join(my_rsample_CIs, rsample_CIs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  bootstraps       type      lower      upper     .lower     .upper\n1       1999    student -0.8529496 -0.4470351 -0.8526882 -0.4484207\n2       1999 percentile -0.8020261 -0.3725691 -0.8014797 -0.3731069\n3       1999        BCa -0.8194484 -0.4326284 -0.8191845 -0.4324908\n```\n\n\n:::\n:::\n\n\nAll checks out, with small differences due to the method used to interpolate percentiles and how the acceleration constant is calculated.\n\nAlthough `rsample` does not provide the full set of bootstrap CI variants, the three it does include are probably the most useful ones. \nThe option to include the original sample estimate as an additional result in the `bootstraps` object is also quite nice,\nand the functions smoothly handle computing bootstraps for each of several terms (such as multiple regression coefficient estimates from a given model).\nHowever, the workflow enforced by `rsample` does seem to have a big downside with respect to memory management. \nTaking a bootstrap sample with $B$ replications creates $B$ new datasets (stored in a nested list). \nSimilarly, running `loo_cv()` creates a near-copy of the dataset for every row of the original dataset.\nThese could get to be quite large objects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobject.size(swiss)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6464 bytes\n```\n\n\n:::\n\n```{.r .cell-code}\nobject.size(loo_cv(swiss))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n403696 bytes\n```\n\n\n:::\n\n```{.r .cell-code}\nobject.size(bootstraps(swiss, times = 999))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8561488 bytes\n```\n\n\n:::\n:::\n\n\nEspecially for large datasets, it would be much more memory-efficient to roll together the re-sampling step and the estimation step or to store only the resampled row indices rather than copies of the full dataset. \n\n# Extrapolating coverage rates a la Boos and Zhang\n\nOne big reason that I implemented all these boostrap CI variants in `simhelpers` is to assist with running Monte Carlo simulations of bootstrap procedures. \nThe main novel feature of my implementation is that `bootstrap_CIs()` can compute not just one interval, but a collection of several intervals using different-sized subsamples of bootstrap replicates.\nThe number of bootstrap replicates to use in each interval can be specified by providing a vector to the `B_vals` argument, as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbootstrap_CIs(\n  boot_est = cors_boot$r,\n  boot_se = cors_boot$SE,\n  est = est[\"r\"],\n  se = est[\"SE\"],\n  influence = inf_vals,\n  CI_type = \"BCa\",\n  B_vals = seq(100,1000,100) - 1L,\n  format = \"long\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   bootstraps type      lower      upper\n1          99  BCa -0.8187481 -0.4565992\n2         199  BCa -0.8536818 -0.4314318\n3         299  BCa -0.8163946 -0.4133028\n4         399  BCa -0.8185373 -0.4314318\n5         499  BCa -0.8264171 -0.4314478\n6         599  BCa -0.8209467 -0.4317901\n7         699  BCa -0.8231215 -0.4429049\n8         799  BCa -0.8231215 -0.4314318\n9         899  BCa -0.8213542 -0.4314318\n10        999  BCa -0.8213542 -0.4314478\n```\n\n\n:::\n:::\n\n\n\nIn the context of a simulation study, this feature makes it feasible to compute coverage levels of a bootstrap CI for several different values of $B$, then extrapolate to higher numbers of replicates. \n\n## Simulating bootstrap CIs for a Pearson correlation\n\nHere is a small simulation to demonstrate how all this can work. \nI'll generate samples of size $n = 25$ from a bivariate-$t$ distribution with correlation parameter $\\rho = 0.75$ and with just $\\nu = 8$ degrees of freedom.  With each sample, I'll calculate the sample correlation and a set of bootstrapped confidence intervals with $B = 49, 99, 199, 299, 399$. \nHere's the data-generating function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr_t_bi <- function(n, rho = 0, df = 8) {\n  Sigma <- rho + diag(1 - rho, nrow = 2)\n  mvtnorm::rmvt(n = n, sigma = Sigma, df = df)\n}\n\nrho <- 0.75\ndat <- r_t_bi(25, rho = rho, df = 8)\n```\n:::\n\n\nAnd the estimation function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncor_CI <- function(\n  dat, \n  CI_type = \"percentile\", \n  B_vals = c(49, 99, 199, 299, 399)\n) {\n  \n  # point estimate\n  r_est <- cor(dat[,1], dat[,2])\n  N <- nrow(dat)\n  SE_r <- sqrt((1 - r_est^2)^2 / (N - 1))\n  \n  # Fisher z CI\n  z <- atanh(r_est)\n  SE_z <- 1 / sqrt(N - 3)\n  CI_z <- z + c(-1, 1) * qnorm(0.975) * SE_z\n\n  \n  # empirical influence if needed\n  if (\"BCa\" %in% CI_type) {\n    jacks <- sapply(1:N, \\(x) cor(dat[-x,1], dat[-x,2]))\n    inf_vals <- r_est - jacks\n  } else {\n    inf_vals <- NULL\n  }\n  \n  # bootstrap samples\n  r_boot <- replicate(max(B_vals), {\n    i <- sample(1:N, replace = TRUE, size = N)\n    r <- cor(dat[i,1], dat[i,2])\n    c(r, sqrt((1 - r^2)^2 / (N - 1)))\n  })\n  \n  bs_CIs <- simhelpers::bootstrap_CIs(\n    boot_est = r_boot[1,],\n    boot_se = r_boot[2,],\n    est = r_est,\n    se = SE_r,\n    influence = inf_vals,\n    CI_type = CI_type,\n    B_vals = B_vals,\n    format = \"wide-list\"\n  )\n  \n  tibble::tibble(\n    r = r_est,\n    SE = SE_r,\n    lo = tanh(CI_z[1]),\n    hi = tanh(CI_z[2]),\n    w = mean(r_boot < r_est),\n    a = sum(inf_vals^3) / (6 * sum(inf_vals^2)^1.5),\n    bs_CIs = bs_CIs\n  )\n}\n\nres <- cor_CI(dat, CI_type = c(\"percentile\",\"student\"))\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n      r     SE    lo    hi     w     a bs_CIs      \n  <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <btstr_CI>  \n1 0.788 0.0774 0.570 0.902 0.723   NaN <df [5 × 5]>\n```\n\n\n:::\n:::\n\n\n\nSetting the argument `format = \"wide-list\"` in the call to `generate_CIs()` makes it convenient to store all the CIs in a nested list-column. Here's the contents of `bs_CIs`: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nres$bs_CIs[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  bootstraps student_lower student_upper percentile_lower percentile_upper\n1         49     0.6017501     0.9143423        0.5580763        0.8898411\n2         99     0.5510270     0.8967928        0.6059297        0.9029773\n3        199     0.5312326     0.9102482        0.5697594        0.9073084\n4        299     0.5327977     0.8988743        0.6005613        0.9069798\n5        399     0.5510270     0.9054740        0.5829886        0.9029773\n```\n\n\n:::\n:::\n\n\n\nNow let me pass these functions to `simhelpers::bundle_sim()` so that I can replicate the data-generation and estimation calls as many times as I like.\nCalling the resulting function gives me 2000 replications of the whole process, where each replication involves generating $B = 399$ bootstraps and also $n$ leave-one-out jack-knife values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# bundle the data-generating and estimation functions \n# into a simulation driver\nsim_cor <- bundle_sim(r_t_bi, cor_CI)\n\n# Run many replications\nsim_reps <- sim_cor(\n  reps = 2000, \n  n = 25, rho = rho,\n  B_vals = c(49, 99, 199, 299, 399),\n  CI_type = c(\"normal\",\"student\",\"basic\",\"percentile\",\"bias-corrected\", \"BCa\")\n)\nhead(sim_reps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n      r     SE    lo    hi     w        a bs_CIs       \n  <dbl>  <dbl> <dbl> <dbl> <dbl>    <dbl> <btstr_CI>   \n1 0.507 0.152  0.140 0.752 0.721 -0.0768  <df [5 × 13]>\n2 0.866 0.0509 0.717 0.940 0.747  0.0203  <df [5 × 13]>\n3 0.679 0.110  0.388 0.847 0.767  0.112   <df [5 × 13]>\n4 0.677 0.111  0.385 0.846 0.766  0.0941  <df [5 × 13]>\n5 0.807 0.0711 0.605 0.912 0.754  0.0252  <df [5 × 13]>\n6 0.813 0.0691 0.616 0.914 0.746 -0.00761 <df [5 × 13]>\n```\n\n\n:::\n:::\n\n\nNow I'll summarize across replications to evaluate the coverage rates of each set of confidence intervals. For the Fisher intervals, `simhelpers::calc_coverage()` does the trick, but for the bootstrap intervals I need to use `simhelpers::extrapolate_coverage()` because each replication is a specially structured _set_ of multiple confidence intervals with different values of $B$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperf <- \n  sim_reps %>%\n  summarize(\n    calc_absolute(estimates = r, true_param = rho, criteria = \"bias\"),\n    calc_coverage(lower_bound = lo, upper_bound = hi, true_param = rho),\n    extrapolate_coverage(\n      CI_subsamples = bs_CIs, true_param = rho, \n      B_target = 1999,\n      nested = TRUE, format = \"long\"\n    )\n  )\n\n# Bias and Fisher interval\nperf %>%\n  select(bias, coverage, width)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n      bias coverage width\n     <dbl>    <dbl> <dbl>\n1 -0.00879    0.919 0.377\n```\n\n\n:::\n:::\n\n\nThe correlation has a slight negative bias. The Fisher $z$ interval has coverage a bit below nominal and an average width of 0.377.\nHere is the performance summary of all the percentile intervals:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_performance <- \n  perf %>%\n  select(starts_with(\"boot\")) %>%\n  unnest(everything())\n\nboot_performance %>%\n  filter(CI_type == \"percentile\") %>%\n  select(CI_type, bootstraps, boot_coverage, boot_width)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  CI_type    bootstraps boot_coverage boot_width\n  <chr>           <dbl>         <dbl>      <dbl>\n1 percentile         49         0.896      0.371\n2 percentile         99         0.914      0.390\n3 percentile        199         0.921      0.400\n4 percentile        299         0.917      0.391\n5 percentile        399         0.924      0.396\n6 percentile       1999         0.926      0.400\n```\n\n\n:::\n:::\n\n\nIn addition to the coverage rates and average widths of intervals based on between 49 and 399 bootstraps, the results also include performance summaries for intervals with $B = 1999$ bootstraps, based on the Boos and Zhang extrapolation method.\nHere's a graph showing the extrapolated coverage rates for each of the CI variants:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nboot_performance_top <- filter(boot_performance, bootstraps == 1999)\n\nggplot(boot_performance) +\n  aes(x = bootstraps, y = boot_coverage, color = CI_type) + \n  scale_x_continuous(breaks = c(49,99,199,399,1999), transform = \"reciprocal\") + \n  scale_y_continuous(limits = c(0.8,1.0), expand = expansion(0, 0), sec.axis = dup_axis(name = \"\")) + \n  geom_hline(yintercept = 0.95, linetype = \"dashed\") + \n  geom_hline(data = perf, aes(yintercept = coverage), color = \"darkgrey\") + \n  geom_point() + \n  ggrepel::geom_label_repel(\n    data = boot_performance_top, \n    aes(label = CI_type), \n    nudge_x = -0.004\n  ) + \n  geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE) + \n  theme_minimal() + \n  theme(legend.position = \"none\") + \n  labs(\n    x = \"Bootstraps (B)\", \n    y = \"CI coverage rate\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=100%}\n:::\n:::\n\n\nThe studentized interval gets very close to the nominal coverage level with $B = 1999$ bootstraps.\nSurprisingly, BCa does not do nearly as well and is worse than the regular percentile interval.   \nPerhaps this is because, for this simple problem, the extra machinery of the bias and acceleration corrections might not be needed or the corrections cannot be estimated accurately enough with a sample of this size. \n\nHere's the average widths of each variant:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nboot_performance_bottom <- filter(boot_performance, bootstraps == 49)\n\nggplot(boot_performance) +\n  aes(x = bootstraps, y = boot_width, color = CI_type) + \n  scale_x_continuous(breaks = c(49,99,199,399,1999), transform = \"reciprocal\") + \n  geom_hline(data = perf, aes(yintercept = width), color = \"darkgrey\") + \n  geom_point() + \n  ggrepel::geom_label_repel(\n    data = boot_performance_bottom, \n    aes(label = CI_type), \n    nudge_x = 0.004\n  ) + \n  geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE) + \n  theme_minimal() + \n  theme(legend.position = \"none\") + \n  labs(\n    x = \"Bootstraps (B)\", \n    y = \"Average CI width\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=100%}\n:::\n:::\n\n\nThe near-nominal coverage rate for the studentized interval comes with an increased width. The percentile and basic CIs have identical widths because they're based on the same percentiles, just used in different ways.\nNotably, the percentile interval has shorter average width than the bias-corrected or BCa intervals, even though it also has better coverage. \n\n## Timing\n\nThis particular problem is perhaps not the most compelling way illustrate Boos and Zhang's extrapolation method because it would fairly simple to just compute a larger number of bootstraps and not worry about the complications of computing a bunch of extra CIs and extrapolating. \nHere's some timing comparisons. \nFirst, the brute-force approach of just computing $B=1999$ bootstraps for each of 500 replications:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\n\ntic()\nperf_1999 <- \n  sim_cor(\n    reps = 500, \n    n = 25, rho = 0.75,\n    B_vals = 1999,\n    CI_type = c(\"normal\",\"student\",\"basic\",\"percentile\",\"bias-corrected\", \"BCa\")\n  ) %>%\n  unnest(bs_CIs) %>%\n  pivot_longer(\n    c(ends_with(\"_lower\"), ends_with(\"_upper\")),\n    names_pattern = \"(.+)_(.+)\",\n    names_to = c(\"CI_type\",\".value\")\n  ) %>%\n  group_by(CI_type) %>%\n  summarize(\n    calc_coverage(lower_bound = lower, upper_bound = upper, true_param = 0.75)\n  )\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n30.95 sec elapsed\n```\n\n\n:::\n:::\n\n\nCompare that to doing 500 replications, each with 399 bootstraps but computing 5 confidence intervals each time and then extrapolating out to $B = 1999$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntic()\nperf_extra <- \n  sim_cor(\n    reps = 500, \n    n = 25, rho = 0.75,\n    B_vals = c(49, 99, 199, 299, 399),\n    CI_type = c(\"normal\",\"student\",\"basic\",\"percentile\",\"bias-corrected\", \"BCa\")\n  ) %>%\n  summarize(\n    extrapolate_coverage(\n      CI_subsamples = bs_CIs, true_param = rho, \n      B_target = 1999,\n      nested = TRUE, format = \"long\"\n    )\n  )\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n11.28 sec elapsed\n```\n\n\n:::\n:::\n\n\nThere is some time savings, but perhaps not worth the extra hassle in this instance. \nThe extrapolation method is much more useful when the statistic calculated on each bootstrap re-sample takes a relatively long time to compute, so that using only a fraction of the bootstraps (399 versus 1999, in this example) substantially reduces the total compute time. \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}