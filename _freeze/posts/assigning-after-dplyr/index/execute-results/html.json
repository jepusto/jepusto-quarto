{
  "hash": "ff1e20208e99fdb1515b079fac7b94c5",
  "result": {
    "markdown": "---\ntitle: Assigning after dplyr\nauthors: admin\ndate: '2016-05-13'\ncategories:\n- Rstats\n- programming\ncode-tools: true\n\n---\n\n\nHadley Wickham's [dplyr](https://github.com/hadley/dplyr) and [tidyr](https://github.com/hadley/tidyr) packages completely changed the way I do data manipulation/munging in R. These packages make it possible to write shorter, faster, more legible, easier-to-intepret code to accomplish the sorts of manipulations that you have to do with practically any real-world data analysis. The legibility and interpretability benefits come from\n\n* using functions that are simple verbs that do exactly what they say (e.g., `filter`, `summarize`, `group_by`) and\n* chaining multiple operations together, through the pipe operator `%>%` from the [magrittr](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html) package. \n\nChaining is particularly nice because it makes the code read like a story. For example, here's the code to calculate sample means for the baseline covariates in a little experimental dataset I've been working with recently:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ndat <- read.csv(\"http://jepusto.com/data/Mineo_2009_data.csv\")\n\ndat %>%\n  group_by(Condition) %>%\n  select(Age, starts_with(\"Baseline\")) %>%\n  summarise_each(funs(mean)) ->\n  baseline_means\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `summarise_each()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n```\n:::\n:::\n\n\nEach line of the code is a different action: first group the data by `Condition`, then select the relevant variables, then summarise each of the variables with its sample mean in each group. The results are stored in a dataset called `baseline_means`.\n\nAs I've gotten familiar with `dplyr`, I've adopted the style of using the backwards assignment operator (`->`) to store the results of a chain of manipulations. This is perhaps a little bit odd---in all the rest of my code I stick with the forward assignment operator (`<-`) with the object name on the left---but the alternative is to break the \"flow\" of the story, effectively putting the punchline before the end of the joke. Consider: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseline_means <- dat %>%\n  group_by(Condition) %>%\n  select(Age, starts_with(\"Baseline\")) %>%\n  summarise_each(funs(mean))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `summarise_each()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `Condition`\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n```\n:::\n:::\n\n\nThat's just confusing to me. So backward assignment operator it is. \n\n### Assigning as a verb\n\nMy only problem with this convention is that, with complicated chains of manipulations, I often find that I need to tweak the order of the verbs in the chain. For example, I might want to summarize _all_ of the variables, and only then select which ones to store: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>%\n  group_by(Condition) %>%\n  summarise_each(funs(mean)) %>%\n  select(Age, starts_with(\"Baseline\")) ->\n  baseline_means\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `summarise_each()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There were 3 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `Expressive.Language = mean(Expressive.Language)`.\nℹ In group 1: `Condition = \"OtherVR\"`.\nCaused by warning in `mean.default()`:\n! argument is not numeric or logical: returning NA\nℹ Run `dplyr::last_dplyr_warnings()` to see the 2 remaining warnings.\n```\n:::\n:::\n\n\nIn revising the code, it's necessary to change the symbols at the end of the second and third steps, which is a minor hassle. It's possible to do it by very carefully cutting-and-pasting the end of the second step through everything but the `->` after the third step, but that's a delicate operation, prone to error if you're programming after hours or after beer. Wouldn't it be nice if every step in the chain ended with `%>%` so that you could move around whole lines of code without worrying about the bit at the end?\n\nHere's one crude way to end each link in the chain with a pipe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>%\n  group_by(Condition) %>%\n  select(Age, starts_with(\"Baseline\")) %>%\n  summarise_each(funs(mean)) %>%\n  identity() -> baseline_means\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `summarise_each()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `Condition`\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n```\n:::\n:::\n\n\nBut this is still pretty ugly---it's got an extra function call that's not a verb, and the name of the resulting object is tucked away in the middle of a line. What I need is a verb to take the results of a chain of operations and assign to an object. Base R has a suitable candidate here: the `assign` function. How about the following? \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>%\n  group_by(Condition) %>%\n  select(Age, starts_with(\"Baseline\")) %>%\n  summarise_each(funs(mean)) %>%\n  assign(\"baseline_means_new\", .)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `summarise_each()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `Condition`\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n```\n:::\n\n```{.r .cell-code}\nexists(\"baseline_means_new\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThis doesn't work because of some subtlety with the environment into which `baseline_means_new` is assigned. A brute-force fix would be to specify that the assign should be into the global environment. This will probably work 90%+ of the time, but it's still not terribly elegant. \n\nHere's a function that searches the call stack to find the most recent invocation of itself that does not involve non-standard evaluation, then assigns to its parent environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nput <- function(x, name, where = NULL) {\n  if (is.null(where)) {\n    sys_calls <- sys.calls()\n    put_calls <- grepl(\"\\\\<put\\\\(\", sys_calls) & !grepl(\"\\\\<put\\\\(\\\\.\",sys_calls)\n    where <- sys.frame(max(which(put_calls)) - 1)\n  }\n  assign(name, value = x, pos = where)\n}\n```\n:::\n\n\nHere are my quick tests that this function is assigning to the right environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nput(dat, \"dat1\")\ndat %>% put(\"dat2\")\n\nf <- function(dat, name) {\n  put(dat, \"dat3\")\n  dat %>% put(\"dat4\")\n  put(dat, name)\n  c(exists(\"dat3\"), exists(\"dat4\"), exists(name))\n}\n\nf(dat,\"dat5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\ngrep(\"dat\",ls(), value = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dat\"  \"dat1\" \"dat2\"\n```\n:::\n:::\n\n\nThis appears to work even if you've got multiple nested calls to `put`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nput(f(dat, \"dat6\"), \"dat7\")\ngrep(\"dat\",ls(), value = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dat\"  \"dat1\" \"dat2\" \"dat7\"\n```\n:::\n\n```{.r .cell-code}\ndat7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n\n```{.r .cell-code}\nf(dat, \"dat8\") %>% put(\"dat9\")\ngrep(\"dat\",ls(), value = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"dat\"  \"dat1\" \"dat2\" \"dat7\" \"dat9\"\n```\n:::\n\n```{.r .cell-code}\ndat9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n:::\n\n\n### It works! (I think...)\n\nTo be consistent with the style of dplyr, let me also tweak the function to allow `name` to be the unquoted object name: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nput <- function(x, name, where = NULL) {\n  name_string <- deparse(substitute(name))\n  if (is.null(where)) {\n    sys_calls <- sys.calls()\n    put_calls <- grepl(\"\\\\<put\\\\(\", sys_calls) & !grepl(\"\\\\<put\\\\(\\\\.\",sys_calls)\n    where <- sys.frame(max(which(put_calls)) - 1)\n  }\n  assign(name_string, value = x, pos = where)\n}\n```\n:::\n\n\nReturning to my original chain of manipulations, here's how it looks with the new function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>%\n  group_by(Condition) %>%\n  select(Age, starts_with(\"Baseline\")) %>%\n  summarise_each(funs(mean)) %>%\n  put(baseline_means_new)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `summarise_each()` was deprecated in dplyr 0.7.0.\nℹ Please use `across()` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAdding missing grouping variables: `Condition`\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean, median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(., na.rm = TRUE))\n```\n:::\n\n```{.r .cell-code}\nprint(baseline_means_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  Condition   Age Baseline.Gaze Baseline.Vocalizations\n  <chr>     <dbl>         <dbl>                  <dbl>\n1 OtherVR    122.          91.9                   2.86\n2 SelfVR     139.          95.5                   1.43\n3 SelfVid    121.         102.                    1.86\n```\n:::\n:::\n\n\nIf you've been following along, let me know what you think of this. Is it a good idea, or is it dangerous? Are there cases where this will break? Can you think of a better name?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}