<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.552">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-09-15">

<title>James E. Pustejovsky - Implementing Efron’s double Poisson distribution in Stan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">James E. Pustejovsky</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../people.html"> 
<span class="menu-text">People</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title">Implementing Efron’s double Poisson distribution in Stan</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
                                <div class="quarto-categories">
                <div class="quarto-category">Bayes</div>
                <div class="quarto-category">simulation</div>
                <div class="quarto-category">distribution-theory</div>
                <div class="quarto-category">generalized linear model</div>
                <div class="quarto-category">programming</div>
                <div class="quarto-category">Rstats</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>admin </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 15, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><span class="math display">\[
\def\Pr{{\text{Pr}}}
\def\E{{\text{E}}}
\def\Var{{\text{Var}}}
\def\Cov{{\text{Cov}}}
\def\bm{\mathbf}
\def\bs{\boldsymbol}
\]</span></p>
<p>For a project I am working on, we are using <a href="https://mc-stan.org/">Stan</a> to fit generalized random effects location-scale models to a bunch of count data. We’re interested in using the double-Poisson distribution, as described by <a href="https://doi.org/10.2307/2289002">Efron (1986)</a>. This is an interesting distribution because it admits for both over- and under-dispersion relative to the Poisson distribution, whereas most of the conventional alternatives such as the negative binomial distribution or Poisson-normal mixture distribution allow only for over-dispersion. The double-Poisson distribution is not implemented in Stan, so we’ve had to write our own distribution function. That’s fine and not particularly difficult. What’s a bit more of a challenge is writing Stan functions to generate random samples from the double-Poisson, so that we can generate posterior predictive checks.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> In this post, I’ll walk through the implementation of the custom distribution functions needed to use the double-Poisson in Stan. The <a href="https://cran.r-project.org/package=gamlss.dist"><code>gamlss.dist</code> package</a> provides a full set of distributional functions for the double-Poisson distribution, including a sampler. Thus, I can validate my Stan functions against the functions from <code>gamlss.dist</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)   <span class="co"># composing figures</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gamlss.dist) <span class="co"># DPO distribution functions</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rstan)       <span class="co"># Stan interface to R</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(brms)        <span class="co"># fitting generalized linear models</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(bayesplot)   <span class="co"># Examine fitted models</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(loo)         <span class="co"># Model fit measures</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="the-double-poisson" class="level2">
<h2 class="anchored" data-anchor-id="the-double-poisson">The double-Poisson</h2>
<p>The double-Poisson distribution is a discrete distribution for non-negative counts, with support <span class="math inline">\(\mathcal{S}_X = \{0, 1, 2, 3, ...\}\)</span>. The mean-variance relationship of the double-Poisson is approximately constant; for <span class="math inline">\(X \sim DPO(\mu, \phi)\)</span>, <span class="math inline">\(\text{E}(X) \approx \mu\)</span> and <span class="math inline">\(\text{Var}(X) \approx \mu / \phi\)</span>, so that the double-Poisson distribution approximately satisfies the assumptions of a quasi-Poisson generalized linear model (although not quite exactly so).</p>
<p><a href="https://doi.org/10.2307/2289002">Efron (1986)</a> gives the following expression for the density of the double-Poisson distribution with mean <span class="math inline">\(\mu\)</span> and inverse-disperson <span class="math inline">\(\phi\)</span>: <span class="math display">\[
f(x | \mu, \phi) = \frac{\phi^{1/2} e^{-\phi \mu}}{c(\mu,\phi)} \left(\frac{e^{-x} x^x}{x!}\right) \left(\frac{e \mu}{x}\right)^{\phi x},
\]</span> where <span class="math inline">\(c(\mu,\phi)\)</span> is a scaling constant to ensure that the density sums to one, which is closely approximated by <span class="math display">\[
c(\mu, \phi) \approx 1 + \frac{1 - \phi}{12 \mu \phi}\left(1 + \frac{1}{\mu \phi}\right).
\]</span> We then have <span class="math display">\[
\ln f(x | \mu, \phi) = \frac{1}{2} \ln \phi - \phi \mu - \ln c(\mu, \phi) + x (\phi + \phi \ln \mu - 1) + (1 - \phi) x \ln(x) - \ln \left(x!\right),
\]</span> where <span class="math inline">\(0 \times \ln (0)\)</span> is evaluated as 0.</p>
</section>
<section id="log-of-the-probability-mass-function" class="level1">
<h1>Log of the probability mass function</h1>
<p>For purposes of using this distribution in Stan, it’s sufficient to provide the log of the probability mass function up to a constant—there’s no need to normalize it to sum to one. Thus, we can ignore the <span class="math inline">\(c(\mu, \phi)\)</span> term above. Here’s a Stan function implementing the lpmf:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>stancode_lpmf <span class="ot">&lt;-</span> <span class="st">"</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="st">real dpo_lpmf(int X, real mu, real phi) {</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="st">  real ans;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="st">  real A = inv(2) * log(phi) - phi * mu;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="st">  if (X == 0)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="st">    ans = A;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="st">  else</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="st">    ans = A + X * (phi * (1 + log(mu)) - 1) - lgamma(X + 1) + (1 - phi) * X * log(X);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="st">  return ans;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To check that this is accurate, I’ll compare the Stan function to the corresponding function from <code>gamlss.dist</code> for a couple of different parameter values and for <span class="math inline">\(x = 0,...,100\)</span>. If my function is accurate, the calculated log-probabilities should differ by a constant value for each set of parameters.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(<span class="fu">paste</span>(<span class="st">"functions {"</span>, stancode_lpmf, <span class="st">"}"</span>, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>), <span class="st">"DPO-lpmf.stan"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">expose_stan_functions</span>(<span class="st">"DPO-lpmf.stan"</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>test_lpmf <span class="ot">&lt;-</span> </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">expand_grid</span>(</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>),</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">phi =</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>),</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">X =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">100</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamlss_lpmf =</span> <span class="fu">dDPO</span>(<span class="at">x =</span> X, <span class="at">mu =</span> mu, <span class="at">sigma =</span> <span class="dv">1</span> <span class="sc">/</span> phi, <span class="at">log =</span> <span class="cn">TRUE</span>),</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">my_lpmf =</span> <span class="fu">pmap_dbl</span>(<span class="at">.l =</span> <span class="fu">list</span>(<span class="at">X =</span> X, <span class="at">mu =</span> mu, <span class="at">phi =</span> phi), <span class="at">.f =</span> dpo_lpmf),</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">diff =</span> my_lpmf <span class="sc">-</span> gamlss_lpmf</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(test_lpmf, <span class="fu">aes</span>(<span class="fu">factor</span>(phi), diff, <span class="at">color =</span> <span class="fu">factor</span>(phi))) <span class="sc">+</span> </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>( <span class="sc">~</span> mu, <span class="at">labeller =</span> <span class="st">"label_both"</span>, <span class="at">ncol =</span> <span class="dv">2</span>) <span class="sc">+</span> </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"phi"</span>) <span class="sc">+</span> </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Checks out. Onward!</p>
</section>
<section id="cumulative-distribution-function" class="level1">
<h1>Cumulative distribution function</h1>
<p>I’ll next implement a function to evaluate the cumulative distriution function over a range of values. This is an expensive calculation, but it can be improved a little bit by noting the relationship between sequential values of the probability mass function. Letting <span class="math inline">\(d = \exp \left(\phi + \phi \ln \mu - 1 \right)\)</span>, observe that <span class="math display">\[
\begin{aligned}
f(0 | \mu, \phi) &amp;= \frac{\phi^{1/2} e^{-\phi \mu}}{c(\mu,\phi)} \\
f(1 | \mu, \phi) &amp;= f(0 | \mu, \phi) \times d \\
f(x | \mu, \phi) &amp;= f(x - 1 | \mu, \phi) \times d \times \frac{\exp\left[(1 - \phi)(x - 1)\left(\ln(x) - \ln(x - 1)\right) \right]}{x^\phi}
\end{aligned}
\]</span> where the last expression holds for <span class="math inline">\(x \geq 2\)</span>.</p>
<p>The function below computes the cumulative distribution function over the range <span class="math inline">\(x = 0,...,m\)</span> as follows:</p>
<ul>
<li>Compute <span class="math inline">\(f(x | \mu, \phi)\)</span> for <span class="math inline">\(x = 0,1,2,...\)</span>, without the scaling constant <span class="math inline">\(c(\mu, \phi)\)</span></li>
<li>Take <span class="math inline">\(F(0 | \mu, \phi) = f(0 | \mu, \phi)\)</span> and accumulate <span class="math inline">\(F(x | \mu, \phi) = F(x - 1 | \mu, \phi) + f(x | \mu, \phi)\)</span> for <span class="math inline">\(x = 0,...,m\)</span>.</li>
<li>Check if <span class="math inline">\(f(x | \mu, \phi) / F(x | \mu, \phi)\)</span> is small (less than <span class="math inline">\(10^{-8}\)</span>), in which case accumulation stops at the value <span class="math inline">\(n\)</span>.</li>
<li>The normalized cumulative distribution function will then be <span class="math inline">\(F(x | \mu, \phi) / F(n | \mu, \phi)\)</span>.</li>
</ul>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>stancode_cdf <span class="ot">&lt;-</span> <span class="st">" </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="st">vector dpo_cdf_vec(real mu, real phi, int maxval) {</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="st">  real d = exp(phi * (1 + log(mu)) - 1);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="st">  real prob;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="st">  int n = maxval + 1;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[n] cdf;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="st">  cdf[1] = sqrt(phi) * exp(-mu * phi);</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="st">  prob = cdf[1] * d;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="st">  cdf[2] = cdf[1] + prob;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in 2:maxval) {</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="st">    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="st">    cdf[i + 1] = cdf[i] + prob;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="st">    if (prob / cdf[i + 1] &lt; 1e-8) {</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="st">      n = i + 1;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="st">      break;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="st">  return cdf / cdf[n];</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To check that this is accurate, I’ll again compare the Stan function to the corresponding function from <code>gamlss.dist</code>. If my function is accurate, the computed cdf values should be proportional to the cdf calculated from <code>gamlss.dist::pDPO()</code> and the ratio should be very close to 1.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(<span class="fu">paste</span>(<span class="st">"functions {"</span>, stancode_cdf, <span class="st">"}"</span>, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>), <span class="st">"DPO-cdf.stan"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">expose_stan_functions</span>(<span class="st">"DPO-cdf.stan"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>test_cdf <span class="ot">&lt;-</span> </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">expand_grid</span>(</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>),</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">phi =</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>),</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">maxval =</span> <span class="dv">20</span> <span class="sc">*</span> mu <span class="sc">/</span> <span class="fu">pmin</span>(<span class="dv">1</span>, phi),</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">my_cdf =</span> <span class="fu">pmap</span>(<span class="at">.l =</span> <span class="fu">list</span>(<span class="at">mu =</span> mu, <span class="at">phi =</span> phi, <span class="at">maxval =</span> maxval), <span class="at">.f =</span> dpo_cdf_vec)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(my_cdf) <span class="sc">%&gt;%</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.nan</span>(my_cdf)) <span class="sc">%&gt;%</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(mu, phi) <span class="sc">%&gt;%</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">q =</span> <span class="fu">row_number</span>() <span class="sc">-</span> <span class="dv">1</span>L,</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamlss_cdf =</span> <span class="fu">pDPO</span>(<span class="at">q =</span> q, <span class="at">mu =</span> mu, <span class="at">sigma =</span> <span class="dv">1</span> <span class="sc">/</span> phi),</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">ratio =</span> my_cdf <span class="sc">/</span> gamlss_cdf</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(test_cdf, <span class="fu">aes</span>(<span class="fu">factor</span>(phi), ratio, <span class="at">color =</span> <span class="fu">factor</span>(phi))) <span class="sc">+</span> </span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>( <span class="sc">~</span> mu, <span class="at">labeller =</span> <span class="st">"label_both"</span>, <span class="at">ncol =</span> <span class="dv">2</span>) <span class="sc">+</span> </span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"phi"</span>) <span class="sc">+</span> </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">1</span> <span class="sc">+</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">1e-6</span>, <span class="fl">1e-6</span>)) <span class="sc">+</span> </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Still on track here (although you might wonder—would I be sharing this post if I couldn’t get the function working?).</p>
</section>
<section id="quantile-function-and-sampler" class="level1">
<h1>Quantile function and sampler</h1>
<p>The main other thing we need is a function for generating random samples from the double-Poisson. The <code>gamlss.dist</code> package has the function <code>rDPO()</code> for this purpose. It’s implemented using the standard inversion method, by calculating quantiles of the double-Poisson corresponding to a random sample from a uniform distribution. Just for funzies, I’ll implement the same approach using Stan.</p>
<p>The function below calculates quantiles by finding the minimum value of <span class="math inline">\(q \geq 0\)</span> such that <span class="math inline">\(F(q + 1 | \mu, \phi) \geq p\)</span> for a specified probability <span class="math inline">\(p \in [0, 1]\)</span>. It is vectorized over <span class="math inline">\(p\)</span> and solves for <span class="math inline">\(q\)</span> by starting with the smallest <span class="math inline">\(p\)</span> and continuing through the largest value.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>stancode_quantile <span class="ot">&lt;-</span> <span class="st">" </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="st">vector dpo_cdf_vec(real mu, real phi, int maxval) {</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="st">  real d = exp(phi * (1 + log(mu)) - 1);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="st">  real prob;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="st">  int n = maxval + 1;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[n] cdf;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="st">  cdf[1] = sqrt(phi) * exp(-mu * phi);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="st">  prob = cdf[1] * d;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="st">  cdf[2] = cdf[1] + prob;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in 2:maxval) {</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="st">    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="st">    cdf[i + 1] = cdf[i] + prob;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="st">    if (prob / cdf[i + 1] &lt; 1e-8) {</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="st">      n = i + 1;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="st">      break;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="st">  return cdf / cdf[n];</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="st">array[] int dpo_quantiles(vector p, real mu, real phi, int maxval) {</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="st">  int N = rows(p);</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="st">  array[N] int qs;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="st">  array[N] int indices = sort_indices_asc(p);</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="st">  int j = 0;</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in indices) {</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="st">    while (cdf_vec[j + 1] &lt; p[i]) {</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="st">      j += 1;</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="st">    qs[i] = j;</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="st">  return qs;</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>If my quantile function is accurate, it should match the value computed from <code>gamlss.dist::qDPO()</code> exactly.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(<span class="fu">paste</span>(<span class="st">"functions {"</span>, stancode_quantile, <span class="st">"}"</span>, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>), <span class="st">"DPO-quantile.stan"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">expose_stan_functions</span>(<span class="st">"DPO-quantile.stan"</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>test_quantile <span class="ot">&lt;-</span> </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">expand_grid</span>(</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>),</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">phi =</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>),</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">maxval =</span> <span class="dv">20</span> <span class="sc">*</span> mu <span class="sc">/</span> <span class="fu">pmin</span>(<span class="dv">1</span>, phi),</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">p =</span> <span class="fu">map</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">n</span>(), <span class="sc">~</span> <span class="fu">runif</span>(<span class="dv">100</span>)),</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">my_q =</span> <span class="fu">pmap</span>(<span class="at">.l =</span> <span class="fu">list</span>(<span class="at">p =</span> p, <span class="at">mu =</span> mu, <span class="at">phi =</span> phi, <span class="at">maxval =</span> maxval), <span class="at">.f =</span> dpo_quantiles),</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamlss_q =</span> <span class="fu">pmap</span>(<span class="at">.l =</span> <span class="fu">list</span>(<span class="at">p =</span> p, <span class="at">mu =</span> mu, <span class="at">sigma =</span> <span class="dv">1</span> <span class="sc">/</span> phi), <span class="at">.f =</span> qDPO)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(<span class="fu">c</span>(p, my_q, gamlss_q)) <span class="sc">%&gt;%</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">diff =</span> my_q <span class="sc">-</span> gamlss_q</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(test_quantile, <span class="fu">aes</span>(<span class="fu">factor</span>(phi), diff, <span class="at">color =</span> <span class="fu">factor</span>(phi))) <span class="sc">+</span> </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>() <span class="sc">+</span> </span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>( <span class="sc">~</span> mu, <span class="at">labeller =</span> <span class="st">"label_both"</span>, <span class="at">ncol =</span> <span class="dv">2</span>) <span class="sc">+</span> </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"phi"</span>) <span class="sc">+</span> </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Phew, still got it!</p>
<p>The last piece of the puzzle is to write a sampler by generating random points from a uniform distribution, then computing the double-Poisson quantiles of these random points. I will implement this two ways: first with an argument for the number of random variates to generate and then, more simply, to generate a single random variate.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>stancode_qr <span class="ot">&lt;-</span> <span class="st">"</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="st">real dpo_lpmf(int X, real mu, real phi) {</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="st">  real ans;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="st">  real A = inv(2) * log(phi) - phi * mu;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="st">  if (X == 0)</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="st">    ans = A;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="st">  else</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="st">    ans = A + X * (phi * (1 + log(mu)) - 1) - lgamma(X + 1) + (1 - phi) * X * log(X);</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="st">  return ans;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="st">vector dpo_cdf_vec(real mu, real phi, int maxval) {</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="st">  real d = exp(phi * (1 + log(mu)) - 1);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="st">  real prob;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="st">  int n = maxval + 1;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[n] cdf;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="st">  cdf[1] = sqrt(phi) * exp(-mu * phi);</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="st">  prob = cdf[1] * d;</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="st">  cdf[2] = cdf[1] + prob;</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in 2:maxval) {</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="st">    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="st">    cdf[i + 1] = cdf[i] + prob;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="st">    if (prob / cdf[i + 1] &lt; 1e-8) {</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="st">      n = i + 1;</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="st">      break;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="st">  return cdf / cdf[n];</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="st">array[] int dpo_quantiles(vector p, real mu, real phi, int maxval) {</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a><span class="st">  int N = rows(p);</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="st">  array[N] int qs;</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="st">  array[N] int indices = sort_indices_asc(p);</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="st">  int j = 0;</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in indices) {</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="st">    while (cdf_vec[j + 1] &lt; p[i]) {</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="st">      j += 1;</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a><span class="st">    qs[i] = j;</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a><span class="st">  return qs;</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a><span class="st">array[] int dpo_sample_rng(int n, real mu, real phi, int maxval) {</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[n] p;</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in 1:n) {</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a><span class="st">    p[i] = uniform_rng(0,1);</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a><span class="st">  array[n] int x = dpo_quantiles(p, mu, phi, maxval);</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a><span class="st">  return x;</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a><span class="st">int dpo_quantile(real p, real mu, real phi, int maxval) {</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a><span class="st">  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a><span class="st">  int q = 0;</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a><span class="st">  while (cdf_vec[q + 1] &lt; p) {</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a><span class="st">      q += 1;</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a><span class="st">  return q;</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a><span class="st">int dpo_rng(real mu, real phi, int maxval) {</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a><span class="st">  real p = uniform_rng(0,1);</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a><span class="st">  int x = dpo_quantile(p, mu, phi, maxval);</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a><span class="st">  return x;</span></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a><span class="st">"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>To check this function, I’ll generate some large samples from the double-Poisson with a few different parameter sets. If the sampler is working properly, the empirical cumulative distribution should line up closely with the cumulative distribution computed using <code>gamlss.dist::pDPO()</code>.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(<span class="fu">paste</span>(<span class="st">"functions {"</span>, stancode_qr, <span class="st">"}"</span>, <span class="at">sep =</span> <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>), <span class="st">"DPO-rng.stan"</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">expose_stan_functions</span>(<span class="st">"DPO-rng.stan"</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>test_rng <span class="ot">&lt;-</span> </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">expand_grid</span>(</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">mu =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">20</span>),</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">phi =</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.5</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>),</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="fu">pmap</span>(<span class="at">.l =</span> <span class="fu">list</span>(<span class="at">n =</span> <span class="dv">10000</span>, <span class="at">mu =</span> mu, <span class="at">phi =</span> phi, <span class="at">maxval =</span> <span class="dv">5000</span>), <span class="at">.f =</span> dpo_sample_rng),</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">tb =</span> <span class="fu">map</span>(x, <span class="sc">~</span> <span class="fu">as.data.frame</span>(<span class="fu">table</span>(.x)))</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="sc">-</span>x) <span class="sc">%&gt;%</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(mu, phi) <span class="sc">%&gt;%</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(tb) <span class="sc">%&gt;%</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">.x =</span> <span class="fu">as.integer</span>(<span class="fu">levels</span>(.x))[.x],</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">Freq_cum =</span> <span class="fu">cumsum</span>(Freq) <span class="sc">/</span> <span class="dv">10000</span>,</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamlss_F =</span> <span class="fu">pDPO</span>(<span class="at">q =</span> .x, <span class="at">mu =</span> mu, <span class="at">sigma =</span> <span class="dv">1</span> <span class="sc">/</span> phi)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(test_rng, <span class="fu">aes</span>(gamlss_F, Freq_cum, <span class="at">color =</span> <span class="fu">factor</span>(phi))) <span class="sc">+</span> </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_abline</span>(<span class="at">slope =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">"blue"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>) <span class="sc">+</span> </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_line</span>() <span class="sc">+</span>  </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(phi <span class="sc">~</span> mu, <span class="at">labeller =</span> <span class="st">"label_both"</span>) <span class="sc">+</span> </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span> </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">"Theoretical cdf (gamlss.dist)"</span>, <span class="at">y =</span> <span class="st">"Empirical cdf (my function)"</span>) <span class="sc">+</span> </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Looks pretty good, no?</p>
</section>
<section id="using-the-custom-distribution-functions" class="level1">
<h1>Using the custom distribution functions</h1>
<p>To finish out my tests of these functions, let me demonstrate their use in an actual estimation problem. I’ll generate data based on a simple generalized linear model with a single predictor <span class="math inline">\(X\)</span>, where the outcome <span class="math inline">\(Y\)</span> follows a double-Poisson distribution conditional on <span class="math inline">\(X\)</span>. The data-generating process is:</p>
<p><span class="math display">\[
\begin{aligned}
X &amp;\sim N(0, 1) \\
Y|X &amp;\sim DPO(\mu(X), \phi) \\
\log \mu(X) &amp;= 2 + 0.3 \times X
\end{aligned}
\]</span> To make things interesting, I’ll set the dispersion parameter to <span class="math inline">\(1 / \phi = 0.6\)</span> so that the outcome is <em>under</em>-dispersed relative to the Poisson.</p>
<p>The following code generates a large sample from the data-generating process. To keep things R-centric, I use <code>gamlss.dist::rDPO</code> to generate the outcome.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">20230913</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">600</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="dv">2</span> <span class="sc">+</span> <span class="fl">0.3</span> <span class="sc">*</span> X)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>phi_inv <span class="ot">&lt;-</span> <span class="fl">0.6</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">rDPO</span>(N, <span class="at">mu =</span> mu, <span class="at">sigma =</span> phi_inv)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X =</span> X, <span class="at">Y =</span> Y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Here’s what the sample looks like, along with a smoothed regression estimated using a basic cubic spline:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(dat, <span class="fu">aes</span>(X, Y)) <span class="sc">+</span> </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">alpha =</span> <span class="fl">0.1</span>) <span class="sc">+</span> </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_smooth</span>(<span class="at">method =</span> <span class="st">'gam'</span>, <span class="at">formula =</span> y <span class="sc">~</span> <span class="fu">s</span>(x, <span class="at">bs =</span> <span class="st">"cs"</span>)) <span class="sc">+</span> </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="576"></p>
</figure>
</div>
</div>
</div>
<section id="comparison-models" class="level2">
<h2 class="anchored" data-anchor-id="comparison-models">Comparison models</h2>
<p>Before using the custom distribution, I’ll fit a couple of out-of-the-box models that are useful points of comparison. Surely the simplest, quickest, and dirtiest way to estimate such a regression is with a generalized linear model, using the “quasi-Poisson” family to allow for non-unit dispersion. In R:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>quasi_fit <span class="ot">&lt;-</span> <span class="fu">glm</span>(Y <span class="sc">~</span> X, <span class="at">family =</span> <span class="fu">quasipoisson</span>(<span class="at">link =</span> <span class="st">"log"</span>), <span class="at">data =</span> dat)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(quasi_fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
glm(formula = Y ~ X, family = quasipoisson(link = "log"), data = dat)

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  1.98784    0.01219  163.03   &lt;2e-16 ***
X            0.29276    0.01178   24.85   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

(Dispersion parameter for quasipoisson family taken to be 0.6324771)

    Null deviance: 777.74  on 599  degrees of freedom
Residual deviance: 384.90  on 598  degrees of freedom
AIC: NA

Number of Fisher Scoring iterations: 4</code></pre>
</div>
</div>
<p>This approach recovers the data-generating parameters quite well, with a dispersion estimate of 0.632 compared to the true dispersion parameter of 0.6.</p>
<p>Now let me fit the same generalized linear model but assuming that the outcome follows a true Poisson distribution (with unit dispersion). I’ll fit the model in a Bayesian framework with the <code>brms</code> package.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>Poisson_fit <span class="ot">&lt;-</span> </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">brm</span>(</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    Y <span class="sc">~</span> X, <span class="at">family =</span> <span class="fu">poisson</span>(<span class="at">link =</span> <span class="st">"log"</span>),</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> dat, </span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">warmup =</span> <span class="dv">500</span>, </span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">iter =</span> <span class="dv">1500</span>, </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">chains =</span> <span class="dv">4</span>, </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">cores =</span> <span class="dv">4</span>,</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">seed =</span> <span class="dv">20230913</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Poisson_fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> Family: poisson 
  Links: mu = log 
Formula: Y ~ X 
   Data: dat (Number of observations: 600) 
  Draws: 4 chains, each with iter = 1500; warmup = 500; thin = 1;
         total post-warmup draws = 4000

Regression Coefficients:
          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
Intercept     1.99      0.02     1.96     2.02 1.00     2865     2658
X             0.29      0.01     0.26     0.32 1.00     2552     2381

Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS
and Tail_ESS are effective sample size measures, and Rhat is the potential
scale reduction factor on split chains (at convergence, Rhat = 1).</code></pre>
</div>
</div>
<p>This specification recovers the intercept and slope parameters well too, but doesn’t provide any estimate of dispersion.</p>
<p>As an alternative, I’ll also fit the model using the negative binomial distribution, which is a generalization of the Poisson that allows for over-dispersion (but not under-dispersion):</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>negbin_fit <span class="ot">&lt;-</span> </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">brm</span>(</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    Y <span class="sc">~</span> X, <span class="at">family =</span> <span class="fu">negbinomial</span>(<span class="at">link =</span> <span class="st">"log"</span>),</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> dat, </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">warmup =</span> <span class="dv">500</span>, </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">iter =</span> <span class="dv">1500</span>, </span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">chains =</span> <span class="dv">4</span>, </span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">cores =</span> <span class="dv">4</span>,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">seed =</span> <span class="dv">20230913</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(negbin_fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> Family: negbinomial 
  Links: mu = log; shape = identity 
Formula: Y ~ X 
   Data: dat (Number of observations: 600) 
  Draws: 4 chains, each with iter = 1500; warmup = 500; thin = 1;
         total post-warmup draws = 4000

Regression Coefficients:
          Estimate Est.Error l-95% CI u-95% CI  Rhat Bulk_ESS Tail_ESS
Intercept     1.98      0.01     1.96     1.99  8.46        4        4
X             0.31      0.03     0.29     0.36 11.39        4       NA

Further Distributional Parameters:
                                                                                                                      Estimate
shape 288635341964439312984004668864260822628440088608000200668088264284802644482664682404200862480406040224646204882688664.00
                                                                                                                     Est.Error
shape 499993580246645223926226042864464406466686242028244246282864888460026284662046208044222402820440664060080422624068464.00
               l-95% CI
shape 12948941308882.21
                                                                                                                       u-95% CI
shape 1154541367857757248926006442246840288482660022402000800442022846826208466628446428606800248620604060886464806228422446.00
      Rhat Bulk_ESS Tail_ESS
shape  Inf        4       NA

Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS
and Tail_ESS are effective sample size measures, and Rhat is the potential
scale reduction factor on split chains (at convergence, Rhat = 1).</code></pre>
</div>
</div>
<p>The <code>brms</code> package implements the negative binomial using the rate parameterization, so the <code>shape</code> parameter corresponds to the inverse dispersion. Thus, a large shape parameter (as in the above fit) implies dispersion that is very close to one (i.e., close to the Poisson).</p>
</section>
<section id="double-poisson-model" class="level2">
<h2 class="anchored" data-anchor-id="double-poisson-model">Double-Poisson model</h2>
<p>Now I’ll fit the same model as previously but using my custom-built double-Poisson distribution. Following <a href="https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html">Paul Buerkner’s vignette</a> on using custom distributions in <code>brms</code>, I’ll first specify the custom family object for the double-Poisson:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>double_Poisson <span class="ot">&lt;-</span> <span class="fu">custom_family</span>(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">"dpo"</span>, <span class="at">dpars =</span> <span class="fu">c</span>(<span class="st">"mu"</span>,<span class="st">"phi"</span>),</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">links =</span> <span class="fu">c</span>(<span class="st">"log"</span>,<span class="st">"log"</span>),</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">lb =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="at">ub =</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="cn">NA</span>),</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"int"</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I set the defaults to use a log-link for the mean (just as with the Poisson and negative binomial families) and a log-link for the inverse-dispersion. Next, I’ll create an object to add the custom stan code from above into the code created by <code>brm</code> for fitting the model:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>double_Poisson_stanvars <span class="ot">&lt;-</span> <span class="fu">stanvar</span>(<span class="at">scode =</span> stancode_qr, <span class="at">block =</span> <span class="st">"functions"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I’ll also need to specify a prior to use for the <span class="math inline">\(\phi\)</span> parameter of the double-Poisson distribution:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>phi_prior <span class="ot">&lt;-</span> <span class="fu">prior</span>(<span class="fu">exponential</span>(<span class="dv">1</span>), <span class="at">class =</span> <span class="st">"phi"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now I’m ready to fit the model:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>DPO_fit <span class="ot">&lt;-</span> </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">brm</span>(</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    Y <span class="sc">~</span> X, <span class="at">family =</span> double_Poisson,</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">prior =</span> phi_prior,</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">stanvars =</span> double_Poisson_stanvars,</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> dat, </span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">warmup =</span> <span class="dv">500</span>, </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">iter =</span> <span class="dv">1500</span>, </span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">chains =</span> <span class="dv">4</span>, </span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">cores =</span> <span class="dv">4</span>,</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">seed =</span> <span class="dv">20230913</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(DPO_fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code> Family: dpo 
  Links: mu = log; phi = identity 
Formula: Y ~ X 
   Data: dat (Number of observations: 600) 
  Draws: 4 chains, each with iter = 1500; warmup = 500; thin = 1;
         total post-warmup draws = 4000

Regression Coefficients:
          Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
Intercept     1.99      0.01     1.96     2.01 1.00     3592     2849
X             0.29      0.01     0.27     0.32 1.00     3330     3103

Further Distributional Parameters:
    Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS
phi     1.55      0.09     1.38     1.72 1.00     3043     2560

Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS
and Tail_ESS are effective sample size measures, and Rhat is the potential
scale reduction factor on split chains (at convergence, Rhat = 1).</code></pre>
</div>
</div>
<p>The regression coefficient estimates are basically identical to those from the Poisson and negative-binomial models, estimated with slightly better precision than with the Poisson or negative binomial families. However, we get a posterior for <span class="math inline">\(\phi\)</span> that corresponds to <em>under</em>-dispersion. Here’s the posterior for the dispersion (i.e., <span class="math inline">\(1 / \phi\)</span>):</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mcmc_areas</span>(DPO_fit, <span class="at">pars =</span> <span class="st">"phi"</span>, <span class="at">transformations =</span> \(x) <span class="dv">1</span> <span class="sc">/</span> x) <span class="sc">+</span> </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/DPO-dispersion-1.png" class="img-fluid figure-img" width="480"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="model-comparison" class="level2">
<h2 class="anchored" data-anchor-id="model-comparison">Model comparison</h2>
<p>I’d like to get a sense of how much better the double-Poisson model does with capturing the real data-generating process compared to the simple Poisson model or the negative binomial model. There’s a wide range of diagnostics that can inform such comparisons. I’ll consider the leave-one-out information criteria (LOOIC) and also look at some posterior predictive checks.</p>
<p>To calculate LOOIC for the double-Poisson model, I first need to provide a <code>log_lik</code> function that <code>brms</code> can use<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. Here’s code, using the Stan function from above:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">expose_functions</span>(DPO_fit, <span class="at">vectorize =</span> <span class="cn">TRUE</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>log_lik_dpo <span class="ot">&lt;-</span> <span class="cf">function</span>(i, prep) {</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> brms<span class="sc">::</span><span class="fu">get_dpar</span>(prep, <span class="st">"mu"</span>, <span class="at">i =</span> i)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  phi <span class="ot">&lt;-</span> brms<span class="sc">::</span><span class="fu">get_dpar</span>(prep, <span class="st">"phi"</span>, <span class="at">i =</span> i)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> prep<span class="sc">$</span>data<span class="sc">$</span>Y[i]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dpo_lpmf</span>(y, mu, phi)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I can then compute LOOIC for all three models:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">loo</span>(DPO_fit, Poisson_fit, negbin_fit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Output of model 'DPO_fit':

Computed from 4000 by 600 log-likelihood matrix.

         Estimate   SE
elpd_loo  -1305.7 16.9
p_loo         2.9  0.2
looic      2611.4 33.7
------
MCSE of elpd_loo is 0.0.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.7, 1.3]).

All Pareto k estimates are good (k &lt; 0.7).
See help('pareto-k-diagnostic') for details.

Output of model 'Poisson_fit':

Computed from 4000 by 600 log-likelihood matrix.

         Estimate   SE
elpd_loo  -1330.0 11.3
p_loo         1.3  0.1
looic      2660.1 22.6
------
MCSE of elpd_loo is 0.0.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.5, 0.9]).

All Pareto k estimates are good (k &lt; 0.7).
See help('pareto-k-diagnostic') for details.

Output of model 'negbin_fit':

Computed from 4000 by 600 log-likelihood matrix.

         Estimate   SE
elpd_loo  -1332.9 11.6
p_loo         2.9  0.3
looic      2665.8 23.2
------
MCSE of elpd_loo is NA.
MCSE and ESS estimates assume MCMC draws (r_eff in [0.0, 0.0]).

Pareto k diagnostic values:
                         Count Pct.    Min. ESS
(-Inf, 0.7]   (good)     157   26.2%   2       
   (0.7, 1]   (bad)        0    0.0%   &lt;NA&gt;    
   (1, Inf)   (very bad) 443   73.8%   &lt;NA&gt;    
See help('pareto-k-diagnostic') for details.

Model comparisons:
            elpd_diff se_diff
DPO_fit       0.0       0.0  
Poisson_fit -24.3       6.0  
negbin_fit  -27.2       6.0  </code></pre>
</div>
</div>
<p>By these measures, the double-Poisson model has substantially better fit than either of the other models.</p>
<p>To do posterior predictive checks, I need to provide a <code>posterior_predict</code> function that <code>brms</code> can use. I’ll again do an implementation that uses my custom <code>dpo_rng()</code> from Stan.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>posterior_predict_dpo <span class="ot">&lt;-</span> <span class="cf">function</span>(i, prep, <span class="at">maxval =</span> <span class="cn">NULL</span>, ...) {</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> brms<span class="sc">::</span><span class="fu">get_dpar</span>(prep, <span class="st">"mu"</span>, <span class="at">i =</span> i)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  phi <span class="ot">&lt;-</span> brms<span class="sc">::</span><span class="fu">get_dpar</span>(prep, <span class="st">"phi"</span>, <span class="at">i =</span> i)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">is.null</span>(maxval)) maxval <span class="ot">&lt;-</span> <span class="dv">20</span> <span class="sc">*</span> mu <span class="sc">/</span> <span class="fu">min</span>(phi, <span class="dv">1</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">dpo_rng</span>(mu, phi, <span class="at">maxval =</span> maxval)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Functions in hand, I can now compute posterior predictions for the double-Poisson model and make pretty pictures of them, along with corresponding plots for the Poisson and negative-binomial models.</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>Yrep_Poisson <span class="ot">&lt;-</span> <span class="fu">posterior_predict</span>(Poisson_fit, <span class="at">draws =</span> <span class="dv">400</span>) </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"blue"</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>Poisson_root <span class="ot">&lt;-</span> <span class="fu">ppc_rootogram</span>(dat<span class="sc">$</span>Y, Yrep_Poisson, <span class="at">style =</span> <span class="st">"hanging"</span>) <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Poisson"</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>Yrep_negbin <span class="ot">&lt;-</span> <span class="fu">posterior_predict</span>(negbin_fit, <span class="at">draws =</span> <span class="dv">400</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"green"</span>)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>negbin_root <span class="ot">&lt;-</span> <span class="fu">ppc_rootogram</span>(dat<span class="sc">$</span>Y, Yrep_negbin, <span class="at">style =</span> <span class="st">"hanging"</span>) <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Negative-binomial"</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>Yrep_dpo <span class="ot">&lt;-</span> <span class="fu">posterior_predict</span>(DPO_fit, <span class="at">draws =</span> <span class="dv">400</span>)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"purple"</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>dpo_root <span class="ot">&lt;-</span> <span class="fu">ppc_rootogram</span>(dat<span class="sc">$</span>Y, Yrep_dpo, <span class="at">style =</span> <span class="st">"hanging"</span>) <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Double-Poisson"</span>)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>dpo_root <span class="sc">/</span> Poisson_root <span class="sc">/</span> negbin_root <span class="sc">&amp;</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/ppd-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
<p>The differences in predicted frequencies are not that obvious from these plots. The main notable difference is that the Poisson and negative-binomial distributions predict more small counts (in the range of 0 to 3) than are observed, whereas the double-Poisson does better at matching the observed frequency in this range.</p>
<p>I think the lack of glaring differences in the above plots happens because I’m just looking at the marginal distribution of the outcome, and the (explained) variation due to the predictor dampens the degree of under-dispersion. To see this, I’ll create some plots that are grouped by quintiles of <span class="math inline">\(X\)</span>:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>dat<span class="sc">$</span>g <span class="ot">&lt;-</span> <span class="fu">cut</span>(dat<span class="sc">$</span>X, <span class="at">breaks =</span> <span class="fu">quantile</span>(dat<span class="sc">$</span>X, <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.2</span>)), <span class="at">include.lowest =</span> <span class="cn">TRUE</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"blue"</span>)</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>Poisson_bars <span class="ot">&lt;-</span> <span class="fu">ppc_bars_grouped</span>(</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  dat<span class="sc">$</span>Y, Yrep_Poisson, dat<span class="sc">$</span>g, </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">prob =</span> <span class="fl">0.5</span>, </span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">facet_args =</span> <span class="fu">list</span>(<span class="at">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span> </span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Poisson"</span>)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"green"</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>negbin_bars <span class="ot">&lt;-</span> <span class="fu">ppc_bars_grouped</span>(</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>  dat<span class="sc">$</span>Y, Yrep_negbin, dat<span class="sc">$</span>g, </span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">prob =</span> <span class="fl">0.5</span>, </span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">facet_args =</span> <span class="fu">list</span>(<span class="at">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span> </span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Negative-binomial"</span>)</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"purple"</span>)</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>dpo_bars <span class="ot">&lt;-</span> <span class="fu">ppc_bars_grouped</span>(</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>  dat<span class="sc">$</span>Y, Yrep_dpo, dat<span class="sc">$</span>g, </span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>  <span class="at">prob =</span> <span class="fl">0.5</span>, </span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>  <span class="at">facet_args =</span> <span class="fu">list</span>(<span class="at">ncol =</span> <span class="dv">5</span>)</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span> </span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Double-Poisson"</span>)</span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>dpo_bars <span class="sc">/</span> Poisson_bars <span class="sc">/</span> negbin_bars <span class="sc">&amp;</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/ppd-grouped-1.png" class="img-fluid figure-img" width="1152"></p>
</figure>
</div>
</div>
</div>
<p>Still kind of subtle, I suppose, but you can see more clearly that the double-Poisson does a better job than the other distributions at matching the modes (peaks) of the empirical distribution in each of these subgroups.</p>
<p>One last approach is to look directly at the degree of dispersion in the posterior predictive distributions relative to the actual data. I’ll calculate this dispersion by re-fitting the quick-and-dirty quasi-poisson model in each sample:</p>
<div class="cell">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>dispersion_coef <span class="ot">&lt;-</span> <span class="cf">function</span>(y) {</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  quasi_fit <span class="ot">&lt;-</span> <span class="fu">glm</span>(y <span class="sc">~</span> dat<span class="sc">$</span>X, <span class="at">family =</span> <span class="fu">quasipoisson</span>(<span class="at">link =</span> <span class="st">"log"</span>))</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sum</span>(<span class="fu">residuals</span>(quasi_fit, <span class="at">type =</span> <span class="st">"pearson"</span>)<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> quasi_fit<span class="sc">$</span>df.residual</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"blue"</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>Poisson_disp <span class="ot">&lt;-</span> <span class="fu">ppc_stat</span>(dat<span class="sc">$</span>Y, Yrep_Poisson, <span class="at">stat =</span> dispersion_coef, <span class="at">binwidth =</span> <span class="fl">0.02</span>) <span class="sc">+</span> </span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Poisson"</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"green"</span>)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>negbin_disp <span class="ot">&lt;-</span> <span class="fu">ppc_stat</span>(dat<span class="sc">$</span>Y, Yrep_negbin, <span class="at">stat =</span> dispersion_coef, <span class="at">binwidth =</span> <span class="fl">0.02</span>) <span class="sc">+</span> </span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Negative-binomial"</span>)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="fu">color_scheme_set</span>(<span class="st">"purple"</span>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>dpo_disp <span class="ot">&lt;-</span> <span class="fu">ppc_stat</span>(dat<span class="sc">$</span>Y, Yrep_dpo, <span class="at">stat =</span> dispersion_coef, <span class="at">binwidth =</span> <span class="fl">0.02</span>) <span class="sc">+</span> </span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Double-Poisson"</span>)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>dpo_disp <span class="sc">/</span> Poisson_disp <span class="sc">/</span> negbin_disp <span class="sc">&amp;</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">&amp;</span> </span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">xlim</span>(<span class="fu">c</span>(<span class="fl">0.45</span>, <span class="fl">1.3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/ppc-dispersion-1.png" class="img-fluid figure-img" width="768"></p>
</figure>
</div>
</div>
</div>
<p>From this, we can clearly see that the Poisson and negative binomial model generate data with approximately unit dispersion, which doesn’t match at all with the degree of dispersion in the observed data.</p>
</section>
</section>
<section id="kudos" class="level1">
<h1>Kudos</h1>
<p>So there you have it. It’s really quite feasible to build models with custom distributions. Efron (1986) also describes a double-binomial distribution (as an approximation to the “quasi-binomial” family of generalized linear models), which you could play with implementing for yourself, dear reader, if you are in the mood. Major kudos to <a href="https://paul-buerkner.github.io/">Paul Buerkner</a> for <a href="https://paul-buerkner.github.io/brms/"><code>brms</code></a>, <a href="https://jgabry.github.io/">Jonah Gabry</a> and collaborators for <a href="https://mc-stan.org/bayesplot/"><code>bayesplot</code></a>, and <a href="https://mc-stan.org/about/team/">the incredible team of folks</a> developing <a href="https://mc-stan.org/"><code>Stan</code></a>.</p>
</section>
<section id="colophon" class="level1">
<h1>Colophon</h1>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>R version 4.3.3 (2024-02-29 ucrt)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 11 x64 (build 22621)

Matrix products: default


locale:
[1] LC_COLLATE=English_United States.utf8 
[2] LC_CTYPE=English_United States.utf8   
[3] LC_MONETARY=English_United States.utf8
[4] LC_NUMERIC=C                          
[5] LC_TIME=English_United States.utf8    

time zone: America/Chicago
tzcode source: internal

attached base packages:
[1] stats     graphics  grDevices datasets  utils     methods   base     

other attached packages:
 [1] loo_2.7.0          bayesplot_1.11.1   brms_2.21.0        Rcpp_1.0.12       
 [5] rstan_2.32.6       StanHeaders_2.32.6 gamlss.dist_6.1-1  patchwork_1.2.0   
 [9] lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1      dplyr_1.1.4       
[13] purrr_1.0.2        readr_2.1.5        tidyr_1.3.1        tibble_3.2.1      
[17] ggplot2_3.5.0      tidyverse_2.0.0   

loaded via a namespace (and not attached):
 [1] tidyselect_1.2.1     farver_2.1.1         fastmap_1.1.1       
 [4] tensorA_0.36.2.1     digest_0.6.35        timechange_0.3.0    
 [7] lifecycle_1.0.4      magrittr_2.0.3       posterior_1.5.0     
[10] compiler_4.3.3       rlang_1.1.3          tools_4.3.3         
[13] utf8_1.2.4           yaml_2.3.8           knitr_1.45          
[16] labeling_0.4.3       bridgesampling_1.1-2 htmlwidgets_1.6.4   
[19] pkgbuild_1.4.4       plyr_1.8.9           BH_1.84.0-0         
[22] abind_1.4-5          withr_3.0.0          grid_4.3.3          
[25] stats4_4.3.3         fansi_1.0.6          colorspace_2.1-0    
[28] inline_0.3.19        scales_1.3.0         MASS_7.3-60.0.1     
[31] ggridges_0.5.6       cli_3.6.2            mvtnorm_1.2-4       
[34] rmarkdown_2.26       generics_0.1.3       RcppParallel_5.1.7  
[37] rstudioapi_0.16.0    reshape2_1.4.4       tzdb_0.4.0          
[40] splines_4.3.3        parallel_4.3.3       matrixStats_1.2.0   
[43] vctrs_0.6.5          Matrix_1.6-5         jsonlite_1.8.8      
[46] hms_1.1.3            glue_1.7.0           codetools_0.2-19    
[49] distributional_0.4.0 stringi_1.8.3        gtable_0.3.4        
[52] QuickJSR_1.1.3       munsell_0.5.1        pillar_1.9.0        
[55] htmltools_0.5.7      Brobdingnag_1.2-9    R6_2.5.1            
[58] RcppEigen_0.3.4.0.0  evaluate_0.23        lattice_0.22-5      
[61] backports_1.4.1      renv_1.0.5           rstantools_2.4.0    
[64] coda_0.19-4.1        gridExtra_2.3        nlme_3.1-164        
[67] checkmate_2.3.1      mgcv_1.9-1           xfun_0.42           
[70] pkgconfig_2.0.3     </code></pre>
</div>
</div>


<!-- -->

</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>To be clear up front, what I present is more complicated than really necessary because of these existing R functions to simulate values from the double-Poisson—we can just use the functions from <code>gamlss.dist</code> for purposes of posterior predictive checks (about which more below). I’m trying to work in Stan to the maximum extent possible solely as an excuse to learn more about the language, which I haven’t used much up until today.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>I should also note that the <a href="http://www.bamlss.org/index.html"><code>bamlss</code> package</a> provides similar functionality and can be combined with <code>gamlss.dist</code> to accomplish basically the same thing as I’m going to do here.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The simpler version is what’s needed for generating posterior predictive checks, the fancy version is just to show off how clever I am.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Rather than exposing and calling the Stan function, one could just re-implement the log likelihood in R. (Probably the easier way in practice, but again I’m trying to learn me some Stan here…)<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Of course, I could have saved a bunch of trouble by just using <code>gamlss.dist::rDPO()</code> instead.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb36" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Implementing Efron's double Poisson distribution in Stan</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="an">authors:</span><span class="co"> admin</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> '2023-09-15'</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="an">categories:</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">- Bayes</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">- simulation</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">- distribution-theory</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">- generalized linear model</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">- programming</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="co">- Rstats</span></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="an">code-fold:</span><span class="co"> show</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="an">code-tools:</span><span class="co"> true</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>\def\Pr{{\text{Pr}}}</span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>\def\E{{\text{E}}}</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a>\def\Var{{\text{Var}}}</span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>\def\Cov{{\text{Cov}}}</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>\def\bm{\mathbf}</span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>\def\bs{\boldsymbol}</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>For a project I am working on, we are using <span class="co">[</span><span class="ot">Stan</span><span class="co">](https://mc-stan.org/)</span> to fit generalized random effects location-scale models to a bunch of count data. We're interested in using the double-Poisson distribution, as described by <span class="co">[</span><span class="ot">Efron (1986)</span><span class="co">](https://doi.org/10.2307/2289002)</span>. </span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>This is an interesting distribution because it admits for both over- and under-dispersion relative to the Poisson distribution, whereas most of the conventional alternatives such as the negative binomial distribution or Poisson-normal mixture distribution allow only for over-dispersion. </span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a>The double-Poisson distribution is not implemented in Stan, so we've had to write our own distribution function. That's fine and not particularly difficult. What's a bit more of a challenge is writing Stan functions to generate random samples from the double-Poisson, so that we can generate posterior predictive checks.<span class="ot">[^caveat]</span> In this post, I'll walk through the implementation of the custom distribution functions needed to use the double-Poisson in Stan. </span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>The <span class="co">[</span><span class="ot">`gamlss.dist` package</span><span class="co">](https://cran.r-project.org/package=gamlss.dist)</span> provides a full set of distributional functions for the double-Poisson distribution, including a sampler. Thus, I can validate my Stan functions against the functions from <span class="in">`gamlss.dist`</span>.<span class="ot">[^bamlss]</span></span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a><span class="ot">[^caveat]: </span>To be clear up front, what I present is more complicated than really necessary because of these existing R functions to simulate values from the double-Poisson---we can just use the functions from <span class="in">`gamlss.dist`</span> for purposes of posterior predictive checks (about which more below). </span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>I'm trying to work in Stan to the maximum extent possible solely as an excuse to learn more about the language, which I haven't used much up until today.</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a><span class="ot">[^bamlss]: </span>I should also note that the <span class="co">[</span><span class="ot">`bamlss` package</span><span class="co">](http://www.bamlss.org/index.html)</span> provides similar functionality and can be combined with <span class="in">`gamlss.dist`</span> to accomplish basically the same thing as I'm going to do here.</span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a><span class="in">```{r setup, include = FALSE}</span></span>
<span id="cb36-37"><a href="#cb36-37" aria-hidden="true" tabindex="-1"></a><span class="in">knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.retina = 2)</span></span>
<span id="cb36-38"><a href="#cb36-38" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-39"><a href="#cb36-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-40"><a href="#cb36-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-41"><a href="#cb36-41" aria-hidden="true" tabindex="-1"></a><span class="in">```{r pkgs, warning = FALSE, message = FALSE}</span></span>
<span id="cb36-42"><a href="#cb36-42" aria-hidden="true" tabindex="-1"></a><span class="in">library(tidyverse)</span></span>
<span id="cb36-43"><a href="#cb36-43" aria-hidden="true" tabindex="-1"></a><span class="in">library(patchwork)   # composing figures</span></span>
<span id="cb36-44"><a href="#cb36-44" aria-hidden="true" tabindex="-1"></a><span class="in">library(gamlss.dist) # DPO distribution functions</span></span>
<span id="cb36-45"><a href="#cb36-45" aria-hidden="true" tabindex="-1"></a><span class="in">library(rstan)       # Stan interface to R</span></span>
<span id="cb36-46"><a href="#cb36-46" aria-hidden="true" tabindex="-1"></a><span class="in">library(brms)        # fitting generalized linear models</span></span>
<span id="cb36-47"><a href="#cb36-47" aria-hidden="true" tabindex="-1"></a><span class="in">library(bayesplot)   # Examine fitted models</span></span>
<span id="cb36-48"><a href="#cb36-48" aria-hidden="true" tabindex="-1"></a><span class="in">library(loo)         # Model fit measures</span></span>
<span id="cb36-49"><a href="#cb36-49" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-50"><a href="#cb36-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-51"><a href="#cb36-51" aria-hidden="true" tabindex="-1"></a><span class="fu">## The double-Poisson </span></span>
<span id="cb36-52"><a href="#cb36-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-53"><a href="#cb36-53" aria-hidden="true" tabindex="-1"></a>The double-Poisson distribution is a discrete distribution for non-negative counts, with support $\mathcal{S}_X = <span class="sc">\{</span>0, 1, 2, 3, ...<span class="sc">\}</span>$. </span>
<span id="cb36-54"><a href="#cb36-54" aria-hidden="true" tabindex="-1"></a>The mean-variance relationship of the double-Poisson is approximately constant; for $X \sim DPO(\mu, \phi)$,  $\text{E}(X) \approx \mu$ and $\text{Var}(X) \approx \mu / \phi$, so that the double-Poisson distribution approximately satisfies the assumptions of a quasi-Poisson generalized linear model (although not quite exactly so). </span>
<span id="cb36-55"><a href="#cb36-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-56"><a href="#cb36-56" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">Efron (1986)</span><span class="co">](https://doi.org/10.2307/2289002)</span> gives the following expression for the density of the double-Poisson distribution with mean $\mu$ and inverse-disperson $\phi$:</span>
<span id="cb36-57"><a href="#cb36-57" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-58"><a href="#cb36-58" aria-hidden="true" tabindex="-1"></a>f(x | \mu, \phi) = \frac{\phi^{1/2} e^{-\phi \mu}}{c(\mu,\phi)} \left(\frac{e^{-x} x^x}{x!}\right) \left(\frac{e \mu}{x}\right)^{\phi x},</span>
<span id="cb36-59"><a href="#cb36-59" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-60"><a href="#cb36-60" aria-hidden="true" tabindex="-1"></a>where $c(\mu,\phi)$ is a scaling constant to ensure that the density sums to one, which is closely approximated by </span>
<span id="cb36-61"><a href="#cb36-61" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-62"><a href="#cb36-62" aria-hidden="true" tabindex="-1"></a>c(\mu, \phi) \approx 1 + \frac{1 - \phi}{12 \mu \phi}\left(1 + \frac{1}{\mu \phi}\right).</span>
<span id="cb36-63"><a href="#cb36-63" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-64"><a href="#cb36-64" aria-hidden="true" tabindex="-1"></a>We then have</span>
<span id="cb36-65"><a href="#cb36-65" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-66"><a href="#cb36-66" aria-hidden="true" tabindex="-1"></a>\ln f(x | \mu, \phi) = \frac{1}{2} \ln \phi - \phi \mu - \ln c(\mu, \phi) + x (\phi + \phi \ln \mu - 1) + (1 - \phi) x \ln(x) - \ln \left(x!\right),</span>
<span id="cb36-67"><a href="#cb36-67" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-68"><a href="#cb36-68" aria-hidden="true" tabindex="-1"></a>where $0 \times \ln (0)$ is evaluated as 0.</span>
<span id="cb36-69"><a href="#cb36-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-70"><a href="#cb36-70" aria-hidden="true" tabindex="-1"></a><span class="fu"># Log of the probability mass function</span></span>
<span id="cb36-71"><a href="#cb36-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-72"><a href="#cb36-72" aria-hidden="true" tabindex="-1"></a>For purposes of using this distribution in Stan, it's sufficient to provide the log of the probability mass function up to a constant---there's no need to normalize it to sum to one. Thus, we can ignore the $c(\mu, \phi)$ term above. Here's a Stan function implementing the lpmf:</span>
<span id="cb36-73"><a href="#cb36-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-74"><a href="#cb36-74" aria-hidden="true" tabindex="-1"></a><span class="in">```{r lpmf}</span></span>
<span id="cb36-75"><a href="#cb36-75" aria-hidden="true" tabindex="-1"></a><span class="in">stancode_lpmf &lt;- "</span></span>
<span id="cb36-76"><a href="#cb36-76" aria-hidden="true" tabindex="-1"></a><span class="in">real dpo_lpmf(int X, real mu, real phi) {</span></span>
<span id="cb36-77"><a href="#cb36-77" aria-hidden="true" tabindex="-1"></a><span class="in">  real ans;</span></span>
<span id="cb36-78"><a href="#cb36-78" aria-hidden="true" tabindex="-1"></a><span class="in">  real A = inv(2) * log(phi) - phi * mu;</span></span>
<span id="cb36-79"><a href="#cb36-79" aria-hidden="true" tabindex="-1"></a><span class="in">  if (X == 0)</span></span>
<span id="cb36-80"><a href="#cb36-80" aria-hidden="true" tabindex="-1"></a><span class="in">    ans = A;</span></span>
<span id="cb36-81"><a href="#cb36-81" aria-hidden="true" tabindex="-1"></a><span class="in">  else</span></span>
<span id="cb36-82"><a href="#cb36-82" aria-hidden="true" tabindex="-1"></a><span class="in">    ans = A + X * (phi * (1 + log(mu)) - 1) - lgamma(X + 1) + (1 - phi) * X * log(X);</span></span>
<span id="cb36-83"><a href="#cb36-83" aria-hidden="true" tabindex="-1"></a><span class="in">  return ans;</span></span>
<span id="cb36-84"><a href="#cb36-84" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-85"><a href="#cb36-85" aria-hidden="true" tabindex="-1"></a><span class="in">"</span></span>
<span id="cb36-86"><a href="#cb36-86" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-87"><a href="#cb36-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-88"><a href="#cb36-88" aria-hidden="true" tabindex="-1"></a>To check that this is accurate, I'll compare the Stan function to the corresponding function from <span class="in">`gamlss.dist`</span> for a couple of different parameter values and for $x = 0,...,100$. If my function is accurate, the calculated log-probabilities should differ by a constant value for each set of parameters.</span>
<span id="cb36-89"><a href="#cb36-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-90"><a href="#cb36-90" aria-hidden="true" tabindex="-1"></a><span class="in">```{r check-lpmf, cache = TRUE}</span></span>
<span id="cb36-91"><a href="#cb36-91" aria-hidden="true" tabindex="-1"></a><span class="in">writeLines(paste("functions {", stancode_lpmf, "}", sep = "\n"), "DPO-lpmf.stan")</span></span>
<span id="cb36-92"><a href="#cb36-92" aria-hidden="true" tabindex="-1"></a><span class="in">expose_stan_functions("DPO-lpmf.stan")</span></span>
<span id="cb36-93"><a href="#cb36-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-94"><a href="#cb36-94" aria-hidden="true" tabindex="-1"></a><span class="in">test_lpmf &lt;- </span></span>
<span id="cb36-95"><a href="#cb36-95" aria-hidden="true" tabindex="-1"></a><span class="in">  expand_grid(</span></span>
<span id="cb36-96"><a href="#cb36-96" aria-hidden="true" tabindex="-1"></a><span class="in">    mu = c(2, 5, 10, 20),</span></span>
<span id="cb36-97"><a href="#cb36-97" aria-hidden="true" tabindex="-1"></a><span class="in">    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),</span></span>
<span id="cb36-98"><a href="#cb36-98" aria-hidden="true" tabindex="-1"></a><span class="in">    X = 0:100</span></span>
<span id="cb36-99"><a href="#cb36-99" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-100"><a href="#cb36-100" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-101"><a href="#cb36-101" aria-hidden="true" tabindex="-1"></a><span class="in">    gamlss_lpmf = dDPO(x = X, mu = mu, sigma = 1 / phi, log = TRUE),</span></span>
<span id="cb36-102"><a href="#cb36-102" aria-hidden="true" tabindex="-1"></a><span class="in">    my_lpmf = pmap_dbl(.l = list(X = X, mu = mu, phi = phi), .f = dpo_lpmf),</span></span>
<span id="cb36-103"><a href="#cb36-103" aria-hidden="true" tabindex="-1"></a><span class="in">    diff = my_lpmf - gamlss_lpmf</span></span>
<span id="cb36-104"><a href="#cb36-104" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-105"><a href="#cb36-105" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-106"><a href="#cb36-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-107"><a href="#cb36-107" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.width = 7, fig.height = 4}</span></span>
<span id="cb36-108"><a href="#cb36-108" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(test_lpmf, aes(factor(phi), diff, color = factor(phi))) + </span></span>
<span id="cb36-109"><a href="#cb36-109" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_boxplot() + </span></span>
<span id="cb36-110"><a href="#cb36-110" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap( ~ mu, labeller = "label_both", ncol = 2) + </span></span>
<span id="cb36-111"><a href="#cb36-111" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal() + </span></span>
<span id="cb36-112"><a href="#cb36-112" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(x = "phi") + </span></span>
<span id="cb36-113"><a href="#cb36-113" aria-hidden="true" tabindex="-1"></a><span class="in">  theme(legend.position = "none")</span></span>
<span id="cb36-114"><a href="#cb36-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-115"><a href="#cb36-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-116"><a href="#cb36-116" aria-hidden="true" tabindex="-1"></a>Checks out. Onward!</span>
<span id="cb36-117"><a href="#cb36-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-118"><a href="#cb36-118" aria-hidden="true" tabindex="-1"></a><span class="fu"># Cumulative distribution function</span></span>
<span id="cb36-119"><a href="#cb36-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-120"><a href="#cb36-120" aria-hidden="true" tabindex="-1"></a>I'll next implement a function to evaluate the cumulative distriution function over a range of values. This is an expensive calculation, but it can be improved a little bit by noting the relationship between sequential values of the probability mass function. Letting $d = \exp \left(\phi + \phi \ln \mu - 1 \right)$, observe that</span>
<span id="cb36-121"><a href="#cb36-121" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-122"><a href="#cb36-122" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb36-123"><a href="#cb36-123" aria-hidden="true" tabindex="-1"></a>f(0 | \mu, \phi) &amp;= \frac{\phi^{1/2} e^{-\phi \mu}}{c(\mu,\phi)} <span class="sc">\\</span></span>
<span id="cb36-124"><a href="#cb36-124" aria-hidden="true" tabindex="-1"></a>f(1 | \mu, \phi) &amp;= f(0 | \mu, \phi) \times d <span class="sc">\\</span></span>
<span id="cb36-125"><a href="#cb36-125" aria-hidden="true" tabindex="-1"></a>f(x | \mu, \phi) &amp;= f(x - 1 | \mu, \phi) \times d \times \frac{\exp\left<span class="co">[</span><span class="ot">(1 - \phi)(x - 1)\left(\ln(x) - \ln(x - 1)\right) \right</span><span class="co">]</span>}{x^\phi}</span>
<span id="cb36-126"><a href="#cb36-126" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb36-127"><a href="#cb36-127" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-128"><a href="#cb36-128" aria-hidden="true" tabindex="-1"></a>where the last expression holds for $x \geq 2$.</span>
<span id="cb36-129"><a href="#cb36-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-130"><a href="#cb36-130" aria-hidden="true" tabindex="-1"></a>The function below computes the cumulative distribution function over the range $x = 0,...,m$ as follows: </span>
<span id="cb36-131"><a href="#cb36-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-132"><a href="#cb36-132" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Compute $f(x | \mu, \phi)$ for $x = 0,1,2,...$, without the scaling constant $c(\mu, \phi)$</span>
<span id="cb36-133"><a href="#cb36-133" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Take $F(0 | \mu, \phi) = f(0 | \mu, \phi)$ and accumulate $F(x | \mu, \phi) = F(x - 1 | \mu, \phi) + f(x | \mu, \phi)$ for $x = 0,...,m$.</span>
<span id="cb36-134"><a href="#cb36-134" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>Check if $f(x | \mu, \phi) / F(x | \mu, \phi)$ is small (less than $10^{-8}$), in which case accumulation stops at the value $n$.</span>
<span id="cb36-135"><a href="#cb36-135" aria-hidden="true" tabindex="-1"></a><span class="ss">* </span>The normalized cumulative distribution function will then be $F(x | \mu, \phi) / F(n | \mu, \phi)$.</span>
<span id="cb36-136"><a href="#cb36-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-137"><a href="#cb36-137" aria-hidden="true" tabindex="-1"></a><span class="in">```{r cdf}</span></span>
<span id="cb36-138"><a href="#cb36-138" aria-hidden="true" tabindex="-1"></a><span class="in">stancode_cdf &lt;- " </span></span>
<span id="cb36-139"><a href="#cb36-139" aria-hidden="true" tabindex="-1"></a><span class="in">vector dpo_cdf_vec(real mu, real phi, int maxval) {</span></span>
<span id="cb36-140"><a href="#cb36-140" aria-hidden="true" tabindex="-1"></a><span class="in">  real d = exp(phi * (1 + log(mu)) - 1);</span></span>
<span id="cb36-141"><a href="#cb36-141" aria-hidden="true" tabindex="-1"></a><span class="in">  real prob;</span></span>
<span id="cb36-142"><a href="#cb36-142" aria-hidden="true" tabindex="-1"></a><span class="in">  int n = maxval + 1;</span></span>
<span id="cb36-143"><a href="#cb36-143" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[n] cdf;</span></span>
<span id="cb36-144"><a href="#cb36-144" aria-hidden="true" tabindex="-1"></a><span class="in">  cdf[1] = sqrt(phi) * exp(-mu * phi);</span></span>
<span id="cb36-145"><a href="#cb36-145" aria-hidden="true" tabindex="-1"></a><span class="in">  prob = cdf[1] * d;</span></span>
<span id="cb36-146"><a href="#cb36-146" aria-hidden="true" tabindex="-1"></a><span class="in">  cdf[2] = cdf[1] + prob;</span></span>
<span id="cb36-147"><a href="#cb36-147" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in 2:maxval) {</span></span>
<span id="cb36-148"><a href="#cb36-148" aria-hidden="true" tabindex="-1"></a><span class="in">    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);</span></span>
<span id="cb36-149"><a href="#cb36-149" aria-hidden="true" tabindex="-1"></a><span class="in">    cdf[i + 1] = cdf[i] + prob;</span></span>
<span id="cb36-150"><a href="#cb36-150" aria-hidden="true" tabindex="-1"></a><span class="in">    if (prob / cdf[i + 1] &lt; 1e-8) {</span></span>
<span id="cb36-151"><a href="#cb36-151" aria-hidden="true" tabindex="-1"></a><span class="in">      n = i + 1;</span></span>
<span id="cb36-152"><a href="#cb36-152" aria-hidden="true" tabindex="-1"></a><span class="in">      break;</span></span>
<span id="cb36-153"><a href="#cb36-153" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb36-154"><a href="#cb36-154" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb36-155"><a href="#cb36-155" aria-hidden="true" tabindex="-1"></a><span class="in">  return cdf / cdf[n];</span></span>
<span id="cb36-156"><a href="#cb36-156" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-157"><a href="#cb36-157" aria-hidden="true" tabindex="-1"></a><span class="in">"</span></span>
<span id="cb36-158"><a href="#cb36-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-159"><a href="#cb36-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-160"><a href="#cb36-160" aria-hidden="true" tabindex="-1"></a>To check that this is accurate, I'll again compare the Stan function to the corresponding function from <span class="in">`gamlss.dist`</span>. If my function is accurate, the computed cdf values should be proportional to the cdf calculated from <span class="in">`gamlss.dist::pDPO()`</span> and the ratio should be very close to 1.</span>
<span id="cb36-161"><a href="#cb36-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-162"><a href="#cb36-162" aria-hidden="true" tabindex="-1"></a><span class="in">```{r check-cdf, cache = TRUE}</span></span>
<span id="cb36-163"><a href="#cb36-163" aria-hidden="true" tabindex="-1"></a><span class="in">writeLines(paste("functions {", stancode_cdf, "}", sep = "\n"), "DPO-cdf.stan")</span></span>
<span id="cb36-164"><a href="#cb36-164" aria-hidden="true" tabindex="-1"></a><span class="in">expose_stan_functions("DPO-cdf.stan")</span></span>
<span id="cb36-165"><a href="#cb36-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-166"><a href="#cb36-166" aria-hidden="true" tabindex="-1"></a><span class="in">test_cdf &lt;- </span></span>
<span id="cb36-167"><a href="#cb36-167" aria-hidden="true" tabindex="-1"></a><span class="in">  expand_grid(</span></span>
<span id="cb36-168"><a href="#cb36-168" aria-hidden="true" tabindex="-1"></a><span class="in">    mu = c(2, 5, 10, 20),</span></span>
<span id="cb36-169"><a href="#cb36-169" aria-hidden="true" tabindex="-1"></a><span class="in">    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),</span></span>
<span id="cb36-170"><a href="#cb36-170" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-171"><a href="#cb36-171" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-172"><a href="#cb36-172" aria-hidden="true" tabindex="-1"></a><span class="in">    maxval = 20 * mu / pmin(1, phi),</span></span>
<span id="cb36-173"><a href="#cb36-173" aria-hidden="true" tabindex="-1"></a><span class="in">    my_cdf = pmap(.l = list(mu = mu, phi = phi, maxval = maxval), .f = dpo_cdf_vec)</span></span>
<span id="cb36-174"><a href="#cb36-174" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-175"><a href="#cb36-175" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(my_cdf) %&gt;%</span></span>
<span id="cb36-176"><a href="#cb36-176" aria-hidden="true" tabindex="-1"></a><span class="in">  filter(!is.nan(my_cdf)) %&gt;%</span></span>
<span id="cb36-177"><a href="#cb36-177" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(mu, phi) %&gt;%</span></span>
<span id="cb36-178"><a href="#cb36-178" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-179"><a href="#cb36-179" aria-hidden="true" tabindex="-1"></a><span class="in">    q = row_number() - 1L,</span></span>
<span id="cb36-180"><a href="#cb36-180" aria-hidden="true" tabindex="-1"></a><span class="in">    gamlss_cdf = pDPO(q = q, mu = mu, sigma = 1 / phi),</span></span>
<span id="cb36-181"><a href="#cb36-181" aria-hidden="true" tabindex="-1"></a><span class="in">    ratio = my_cdf / gamlss_cdf</span></span>
<span id="cb36-182"><a href="#cb36-182" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-183"><a href="#cb36-183" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-184"><a href="#cb36-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-185"><a href="#cb36-185" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.width = 7, fig.height = 4}</span></span>
<span id="cb36-186"><a href="#cb36-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-187"><a href="#cb36-187" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(test_cdf, aes(factor(phi), ratio, color = factor(phi))) + </span></span>
<span id="cb36-188"><a href="#cb36-188" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_boxplot() + </span></span>
<span id="cb36-189"><a href="#cb36-189" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap( ~ mu, labeller = "label_both", ncol = 2) + </span></span>
<span id="cb36-190"><a href="#cb36-190" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal() + </span></span>
<span id="cb36-191"><a href="#cb36-191" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(x = "phi") + </span></span>
<span id="cb36-192"><a href="#cb36-192" aria-hidden="true" tabindex="-1"></a><span class="in">  ylim(1 + c(-1e-6, 1e-6)) + </span></span>
<span id="cb36-193"><a href="#cb36-193" aria-hidden="true" tabindex="-1"></a><span class="in">  theme(legend.position = "none")</span></span>
<span id="cb36-194"><a href="#cb36-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-195"><a href="#cb36-195" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-196"><a href="#cb36-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-197"><a href="#cb36-197" aria-hidden="true" tabindex="-1"></a>Still on track here (although you might wonder---would I be sharing this post if I couldn't get the function working?).</span>
<span id="cb36-198"><a href="#cb36-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-199"><a href="#cb36-199" aria-hidden="true" tabindex="-1"></a><span class="fu"># Quantile function and sampler</span></span>
<span id="cb36-200"><a href="#cb36-200" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-201"><a href="#cb36-201" aria-hidden="true" tabindex="-1"></a>The main other thing we need is a function for generating random samples from the double-Poisson. The <span class="in">`gamlss.dist`</span> package has the function <span class="in">`rDPO()`</span> for this purpose. It's implemented using the standard inversion method, by calculating quantiles of the double-Poisson corresponding to a random sample from a uniform distribution. Just for funzies, I'll implement the same approach using Stan.</span>
<span id="cb36-202"><a href="#cb36-202" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-203"><a href="#cb36-203" aria-hidden="true" tabindex="-1"></a>The function below calculates quantiles by finding the minimum value of $q \geq 0$ such that $F(q + 1 | \mu, \phi) \geq p$ for a specified probability $p \in <span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$. It is vectorized over $p$ and solves for $q$ by starting with the smallest $p$ and continuing through the largest value.</span>
<span id="cb36-204"><a href="#cb36-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-205"><a href="#cb36-205" aria-hidden="true" tabindex="-1"></a><span class="in">```{r quantile}</span></span>
<span id="cb36-206"><a href="#cb36-206" aria-hidden="true" tabindex="-1"></a><span class="in">stancode_quantile &lt;- " </span></span>
<span id="cb36-207"><a href="#cb36-207" aria-hidden="true" tabindex="-1"></a><span class="in">vector dpo_cdf_vec(real mu, real phi, int maxval) {</span></span>
<span id="cb36-208"><a href="#cb36-208" aria-hidden="true" tabindex="-1"></a><span class="in">  real d = exp(phi * (1 + log(mu)) - 1);</span></span>
<span id="cb36-209"><a href="#cb36-209" aria-hidden="true" tabindex="-1"></a><span class="in">  real prob;</span></span>
<span id="cb36-210"><a href="#cb36-210" aria-hidden="true" tabindex="-1"></a><span class="in">  int n = maxval + 1;</span></span>
<span id="cb36-211"><a href="#cb36-211" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[n] cdf;</span></span>
<span id="cb36-212"><a href="#cb36-212" aria-hidden="true" tabindex="-1"></a><span class="in">  cdf[1] = sqrt(phi) * exp(-mu * phi);</span></span>
<span id="cb36-213"><a href="#cb36-213" aria-hidden="true" tabindex="-1"></a><span class="in">  prob = cdf[1] * d;</span></span>
<span id="cb36-214"><a href="#cb36-214" aria-hidden="true" tabindex="-1"></a><span class="in">  cdf[2] = cdf[1] + prob;</span></span>
<span id="cb36-215"><a href="#cb36-215" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in 2:maxval) {</span></span>
<span id="cb36-216"><a href="#cb36-216" aria-hidden="true" tabindex="-1"></a><span class="in">    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);</span></span>
<span id="cb36-217"><a href="#cb36-217" aria-hidden="true" tabindex="-1"></a><span class="in">    cdf[i + 1] = cdf[i] + prob;</span></span>
<span id="cb36-218"><a href="#cb36-218" aria-hidden="true" tabindex="-1"></a><span class="in">    if (prob / cdf[i + 1] &lt; 1e-8) {</span></span>
<span id="cb36-219"><a href="#cb36-219" aria-hidden="true" tabindex="-1"></a><span class="in">      n = i + 1;</span></span>
<span id="cb36-220"><a href="#cb36-220" aria-hidden="true" tabindex="-1"></a><span class="in">      break;</span></span>
<span id="cb36-221"><a href="#cb36-221" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb36-222"><a href="#cb36-222" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb36-223"><a href="#cb36-223" aria-hidden="true" tabindex="-1"></a><span class="in">  return cdf / cdf[n];</span></span>
<span id="cb36-224"><a href="#cb36-224" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-225"><a href="#cb36-225" aria-hidden="true" tabindex="-1"></a><span class="in">array[] int dpo_quantiles(vector p, real mu, real phi, int maxval) {</span></span>
<span id="cb36-226"><a href="#cb36-226" aria-hidden="true" tabindex="-1"></a><span class="in">  int N = rows(p);</span></span>
<span id="cb36-227"><a href="#cb36-227" aria-hidden="true" tabindex="-1"></a><span class="in">  array[N] int qs;</span></span>
<span id="cb36-228"><a href="#cb36-228" aria-hidden="true" tabindex="-1"></a><span class="in">  array[N] int indices = sort_indices_asc(p);</span></span>
<span id="cb36-229"><a href="#cb36-229" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);</span></span>
<span id="cb36-230"><a href="#cb36-230" aria-hidden="true" tabindex="-1"></a><span class="in">  int j = 0;</span></span>
<span id="cb36-231"><a href="#cb36-231" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in indices) {</span></span>
<span id="cb36-232"><a href="#cb36-232" aria-hidden="true" tabindex="-1"></a><span class="in">    while (cdf_vec[j + 1] &lt; p[i]) {</span></span>
<span id="cb36-233"><a href="#cb36-233" aria-hidden="true" tabindex="-1"></a><span class="in">      j += 1;</span></span>
<span id="cb36-234"><a href="#cb36-234" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb36-235"><a href="#cb36-235" aria-hidden="true" tabindex="-1"></a><span class="in">    qs[i] = j;</span></span>
<span id="cb36-236"><a href="#cb36-236" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb36-237"><a href="#cb36-237" aria-hidden="true" tabindex="-1"></a><span class="in">  return qs;</span></span>
<span id="cb36-238"><a href="#cb36-238" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-239"><a href="#cb36-239" aria-hidden="true" tabindex="-1"></a><span class="in">"</span></span>
<span id="cb36-240"><a href="#cb36-240" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-241"><a href="#cb36-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-242"><a href="#cb36-242" aria-hidden="true" tabindex="-1"></a>If my quantile function is accurate, it should match the value computed from <span class="in">`gamlss.dist::qDPO()`</span> exactly.</span>
<span id="cb36-243"><a href="#cb36-243" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-244"><a href="#cb36-244" aria-hidden="true" tabindex="-1"></a><span class="in">```{r check-quantile, cache = TRUE}</span></span>
<span id="cb36-245"><a href="#cb36-245" aria-hidden="true" tabindex="-1"></a><span class="in">writeLines(paste("functions {", stancode_quantile, "}", sep = "\n"), "DPO-quantile.stan")</span></span>
<span id="cb36-246"><a href="#cb36-246" aria-hidden="true" tabindex="-1"></a><span class="in">expose_stan_functions("DPO-quantile.stan")</span></span>
<span id="cb36-247"><a href="#cb36-247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-248"><a href="#cb36-248" aria-hidden="true" tabindex="-1"></a><span class="in">test_quantile &lt;- </span></span>
<span id="cb36-249"><a href="#cb36-249" aria-hidden="true" tabindex="-1"></a><span class="in">  expand_grid(</span></span>
<span id="cb36-250"><a href="#cb36-250" aria-hidden="true" tabindex="-1"></a><span class="in">    mu = c(2, 5, 10, 20),</span></span>
<span id="cb36-251"><a href="#cb36-251" aria-hidden="true" tabindex="-1"></a><span class="in">    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),</span></span>
<span id="cb36-252"><a href="#cb36-252" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-253"><a href="#cb36-253" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-254"><a href="#cb36-254" aria-hidden="true" tabindex="-1"></a><span class="in">    maxval = 20 * mu / pmin(1, phi),</span></span>
<span id="cb36-255"><a href="#cb36-255" aria-hidden="true" tabindex="-1"></a><span class="in">    p = map(1:n(), ~ runif(100)),</span></span>
<span id="cb36-256"><a href="#cb36-256" aria-hidden="true" tabindex="-1"></a><span class="in">    my_q = pmap(.l = list(p = p, mu = mu, phi = phi, maxval = maxval), .f = dpo_quantiles),</span></span>
<span id="cb36-257"><a href="#cb36-257" aria-hidden="true" tabindex="-1"></a><span class="in">    gamlss_q = pmap(.l = list(p = p, mu = mu, sigma = 1 / phi), .f = qDPO)</span></span>
<span id="cb36-258"><a href="#cb36-258" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-259"><a href="#cb36-259" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(c(p, my_q, gamlss_q)) %&gt;%</span></span>
<span id="cb36-260"><a href="#cb36-260" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-261"><a href="#cb36-261" aria-hidden="true" tabindex="-1"></a><span class="in">    diff = my_q - gamlss_q</span></span>
<span id="cb36-262"><a href="#cb36-262" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-263"><a href="#cb36-263" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-264"><a href="#cb36-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-265"><a href="#cb36-265" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.width = 7, fig.height = 4}</span></span>
<span id="cb36-266"><a href="#cb36-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-267"><a href="#cb36-267" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(test_quantile, aes(factor(phi), diff, color = factor(phi))) + </span></span>
<span id="cb36-268"><a href="#cb36-268" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_boxplot() + </span></span>
<span id="cb36-269"><a href="#cb36-269" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_wrap( ~ mu, labeller = "label_both", ncol = 2) + </span></span>
<span id="cb36-270"><a href="#cb36-270" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal() + </span></span>
<span id="cb36-271"><a href="#cb36-271" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(x = "phi") + </span></span>
<span id="cb36-272"><a href="#cb36-272" aria-hidden="true" tabindex="-1"></a><span class="in">  theme(legend.position = "none")</span></span>
<span id="cb36-273"><a href="#cb36-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-274"><a href="#cb36-274" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-275"><a href="#cb36-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-276"><a href="#cb36-276" aria-hidden="true" tabindex="-1"></a>Phew, still got it!</span>
<span id="cb36-277"><a href="#cb36-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-278"><a href="#cb36-278" aria-hidden="true" tabindex="-1"></a>The last piece of the puzzle is to write a sampler by generating random points from a uniform distribution, then computing the double-Poisson quantiles of these random points. I will implement this two ways: first with an argument for the number of random variates to generate and then, more simply, to generate a single random variate.<span class="ot">[^clever]</span> </span>
<span id="cb36-279"><a href="#cb36-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-280"><a href="#cb36-280" aria-hidden="true" tabindex="-1"></a><span class="ot">[^clever]: </span>The simpler version is what's needed for generating posterior predictive checks, the fancy version is just to show off how clever I am.</span>
<span id="cb36-281"><a href="#cb36-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-282"><a href="#cb36-282" aria-hidden="true" tabindex="-1"></a><span class="in">```{r rng}</span></span>
<span id="cb36-283"><a href="#cb36-283" aria-hidden="true" tabindex="-1"></a><span class="in">stancode_qr &lt;- "</span></span>
<span id="cb36-284"><a href="#cb36-284" aria-hidden="true" tabindex="-1"></a><span class="in">real dpo_lpmf(int X, real mu, real phi) {</span></span>
<span id="cb36-285"><a href="#cb36-285" aria-hidden="true" tabindex="-1"></a><span class="in">  real ans;</span></span>
<span id="cb36-286"><a href="#cb36-286" aria-hidden="true" tabindex="-1"></a><span class="in">  real A = inv(2) * log(phi) - phi * mu;</span></span>
<span id="cb36-287"><a href="#cb36-287" aria-hidden="true" tabindex="-1"></a><span class="in">  if (X == 0)</span></span>
<span id="cb36-288"><a href="#cb36-288" aria-hidden="true" tabindex="-1"></a><span class="in">    ans = A;</span></span>
<span id="cb36-289"><a href="#cb36-289" aria-hidden="true" tabindex="-1"></a><span class="in">  else</span></span>
<span id="cb36-290"><a href="#cb36-290" aria-hidden="true" tabindex="-1"></a><span class="in">    ans = A + X * (phi * (1 + log(mu)) - 1) - lgamma(X + 1) + (1 - phi) * X * log(X);</span></span>
<span id="cb36-291"><a href="#cb36-291" aria-hidden="true" tabindex="-1"></a><span class="in">  return ans;</span></span>
<span id="cb36-292"><a href="#cb36-292" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-293"><a href="#cb36-293" aria-hidden="true" tabindex="-1"></a><span class="in">vector dpo_cdf_vec(real mu, real phi, int maxval) {</span></span>
<span id="cb36-294"><a href="#cb36-294" aria-hidden="true" tabindex="-1"></a><span class="in">  real d = exp(phi * (1 + log(mu)) - 1);</span></span>
<span id="cb36-295"><a href="#cb36-295" aria-hidden="true" tabindex="-1"></a><span class="in">  real prob;</span></span>
<span id="cb36-296"><a href="#cb36-296" aria-hidden="true" tabindex="-1"></a><span class="in">  int n = maxval + 1;</span></span>
<span id="cb36-297"><a href="#cb36-297" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[n] cdf;</span></span>
<span id="cb36-298"><a href="#cb36-298" aria-hidden="true" tabindex="-1"></a><span class="in">  cdf[1] = sqrt(phi) * exp(-mu * phi);</span></span>
<span id="cb36-299"><a href="#cb36-299" aria-hidden="true" tabindex="-1"></a><span class="in">  prob = cdf[1] * d;</span></span>
<span id="cb36-300"><a href="#cb36-300" aria-hidden="true" tabindex="-1"></a><span class="in">  cdf[2] = cdf[1] + prob;</span></span>
<span id="cb36-301"><a href="#cb36-301" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in 2:maxval) {</span></span>
<span id="cb36-302"><a href="#cb36-302" aria-hidden="true" tabindex="-1"></a><span class="in">    prob = prob * d * exp((1 - phi) * (i - 1) * (log(i) - log(i - 1))) / (i^phi);</span></span>
<span id="cb36-303"><a href="#cb36-303" aria-hidden="true" tabindex="-1"></a><span class="in">    cdf[i + 1] = cdf[i] + prob;</span></span>
<span id="cb36-304"><a href="#cb36-304" aria-hidden="true" tabindex="-1"></a><span class="in">    if (prob / cdf[i + 1] &lt; 1e-8) {</span></span>
<span id="cb36-305"><a href="#cb36-305" aria-hidden="true" tabindex="-1"></a><span class="in">      n = i + 1;</span></span>
<span id="cb36-306"><a href="#cb36-306" aria-hidden="true" tabindex="-1"></a><span class="in">      break;</span></span>
<span id="cb36-307"><a href="#cb36-307" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb36-308"><a href="#cb36-308" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb36-309"><a href="#cb36-309" aria-hidden="true" tabindex="-1"></a><span class="in">  return cdf / cdf[n];</span></span>
<span id="cb36-310"><a href="#cb36-310" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-311"><a href="#cb36-311" aria-hidden="true" tabindex="-1"></a><span class="in">array[] int dpo_quantiles(vector p, real mu, real phi, int maxval) {</span></span>
<span id="cb36-312"><a href="#cb36-312" aria-hidden="true" tabindex="-1"></a><span class="in">  int N = rows(p);</span></span>
<span id="cb36-313"><a href="#cb36-313" aria-hidden="true" tabindex="-1"></a><span class="in">  array[N] int qs;</span></span>
<span id="cb36-314"><a href="#cb36-314" aria-hidden="true" tabindex="-1"></a><span class="in">  array[N] int indices = sort_indices_asc(p);</span></span>
<span id="cb36-315"><a href="#cb36-315" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);</span></span>
<span id="cb36-316"><a href="#cb36-316" aria-hidden="true" tabindex="-1"></a><span class="in">  int j = 0;</span></span>
<span id="cb36-317"><a href="#cb36-317" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in indices) {</span></span>
<span id="cb36-318"><a href="#cb36-318" aria-hidden="true" tabindex="-1"></a><span class="in">    while (cdf_vec[j + 1] &lt; p[i]) {</span></span>
<span id="cb36-319"><a href="#cb36-319" aria-hidden="true" tabindex="-1"></a><span class="in">      j += 1;</span></span>
<span id="cb36-320"><a href="#cb36-320" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb36-321"><a href="#cb36-321" aria-hidden="true" tabindex="-1"></a><span class="in">    qs[i] = j;</span></span>
<span id="cb36-322"><a href="#cb36-322" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb36-323"><a href="#cb36-323" aria-hidden="true" tabindex="-1"></a><span class="in">  return qs;</span></span>
<span id="cb36-324"><a href="#cb36-324" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-325"><a href="#cb36-325" aria-hidden="true" tabindex="-1"></a><span class="in">array[] int dpo_sample_rng(int n, real mu, real phi, int maxval) {</span></span>
<span id="cb36-326"><a href="#cb36-326" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[n] p;</span></span>
<span id="cb36-327"><a href="#cb36-327" aria-hidden="true" tabindex="-1"></a><span class="in">  for (i in 1:n) {</span></span>
<span id="cb36-328"><a href="#cb36-328" aria-hidden="true" tabindex="-1"></a><span class="in">    p[i] = uniform_rng(0,1);</span></span>
<span id="cb36-329"><a href="#cb36-329" aria-hidden="true" tabindex="-1"></a><span class="in">  }</span></span>
<span id="cb36-330"><a href="#cb36-330" aria-hidden="true" tabindex="-1"></a><span class="in">  array[n] int x = dpo_quantiles(p, mu, phi, maxval);</span></span>
<span id="cb36-331"><a href="#cb36-331" aria-hidden="true" tabindex="-1"></a><span class="in">  return x;</span></span>
<span id="cb36-332"><a href="#cb36-332" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-333"><a href="#cb36-333" aria-hidden="true" tabindex="-1"></a><span class="in">int dpo_quantile(real p, real mu, real phi, int maxval) {</span></span>
<span id="cb36-334"><a href="#cb36-334" aria-hidden="true" tabindex="-1"></a><span class="in">  vector[maxval + 1] cdf_vec = dpo_cdf_vec(mu, phi, maxval);</span></span>
<span id="cb36-335"><a href="#cb36-335" aria-hidden="true" tabindex="-1"></a><span class="in">  int q = 0;</span></span>
<span id="cb36-336"><a href="#cb36-336" aria-hidden="true" tabindex="-1"></a><span class="in">  while (cdf_vec[q + 1] &lt; p) {</span></span>
<span id="cb36-337"><a href="#cb36-337" aria-hidden="true" tabindex="-1"></a><span class="in">      q += 1;</span></span>
<span id="cb36-338"><a href="#cb36-338" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb36-339"><a href="#cb36-339" aria-hidden="true" tabindex="-1"></a><span class="in">  return q;</span></span>
<span id="cb36-340"><a href="#cb36-340" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-341"><a href="#cb36-341" aria-hidden="true" tabindex="-1"></a><span class="in">int dpo_rng(real mu, real phi, int maxval) {</span></span>
<span id="cb36-342"><a href="#cb36-342" aria-hidden="true" tabindex="-1"></a><span class="in">  real p = uniform_rng(0,1);</span></span>
<span id="cb36-343"><a href="#cb36-343" aria-hidden="true" tabindex="-1"></a><span class="in">  int x = dpo_quantile(p, mu, phi, maxval);</span></span>
<span id="cb36-344"><a href="#cb36-344" aria-hidden="true" tabindex="-1"></a><span class="in">  return x;</span></span>
<span id="cb36-345"><a href="#cb36-345" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-346"><a href="#cb36-346" aria-hidden="true" tabindex="-1"></a><span class="in">"</span></span>
<span id="cb36-347"><a href="#cb36-347" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-348"><a href="#cb36-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-349"><a href="#cb36-349" aria-hidden="true" tabindex="-1"></a>To check this function, I'll generate some large samples from the double-Poisson with a few different parameter sets. If the sampler is working properly, the empirical cumulative distribution should line up closely with the cumulative distribution computed using <span class="in">`gamlss.dist::pDPO()`</span>.</span>
<span id="cb36-350"><a href="#cb36-350" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-351"><a href="#cb36-351" aria-hidden="true" tabindex="-1"></a><span class="in">```{r check-rng, cache = TRUE}</span></span>
<span id="cb36-352"><a href="#cb36-352" aria-hidden="true" tabindex="-1"></a><span class="in">writeLines(paste("functions {", stancode_qr, "}", sep = "\n"), "DPO-rng.stan")</span></span>
<span id="cb36-353"><a href="#cb36-353" aria-hidden="true" tabindex="-1"></a><span class="in">expose_stan_functions("DPO-rng.stan")</span></span>
<span id="cb36-354"><a href="#cb36-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-355"><a href="#cb36-355" aria-hidden="true" tabindex="-1"></a><span class="in">test_rng &lt;- </span></span>
<span id="cb36-356"><a href="#cb36-356" aria-hidden="true" tabindex="-1"></a><span class="in">  expand_grid(</span></span>
<span id="cb36-357"><a href="#cb36-357" aria-hidden="true" tabindex="-1"></a><span class="in">    mu = c(2, 5, 10, 20),</span></span>
<span id="cb36-358"><a href="#cb36-358" aria-hidden="true" tabindex="-1"></a><span class="in">    phi = c(0.1, 0.2, 0.5, 1, 2, 5, 10),</span></span>
<span id="cb36-359"><a href="#cb36-359" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-360"><a href="#cb36-360" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-361"><a href="#cb36-361" aria-hidden="true" tabindex="-1"></a><span class="in">    x = pmap(.l = list(n = 10000, mu = mu, phi = phi, maxval = 5000), .f = dpo_sample_rng),</span></span>
<span id="cb36-362"><a href="#cb36-362" aria-hidden="true" tabindex="-1"></a><span class="in">    tb = map(x, ~ as.data.frame(table(.x)))</span></span>
<span id="cb36-363"><a href="#cb36-363" aria-hidden="true" tabindex="-1"></a><span class="in">  ) %&gt;%</span></span>
<span id="cb36-364"><a href="#cb36-364" aria-hidden="true" tabindex="-1"></a><span class="in">  dplyr::select(-x) %&gt;%</span></span>
<span id="cb36-365"><a href="#cb36-365" aria-hidden="true" tabindex="-1"></a><span class="in">  group_by(mu, phi) %&gt;%</span></span>
<span id="cb36-366"><a href="#cb36-366" aria-hidden="true" tabindex="-1"></a><span class="in">  unnest(tb) %&gt;%</span></span>
<span id="cb36-367"><a href="#cb36-367" aria-hidden="true" tabindex="-1"></a><span class="in">  mutate(</span></span>
<span id="cb36-368"><a href="#cb36-368" aria-hidden="true" tabindex="-1"></a><span class="in">    .x = as.integer(levels(.x))[.x],</span></span>
<span id="cb36-369"><a href="#cb36-369" aria-hidden="true" tabindex="-1"></a><span class="in">    Freq_cum = cumsum(Freq) / 10000,</span></span>
<span id="cb36-370"><a href="#cb36-370" aria-hidden="true" tabindex="-1"></a><span class="in">    gamlss_F = pDPO(q = .x, mu = mu, sigma = 1 / phi)</span></span>
<span id="cb36-371"><a href="#cb36-371" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-372"><a href="#cb36-372" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-373"><a href="#cb36-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-374"><a href="#cb36-374" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.width = 7, fig.height = 10}</span></span>
<span id="cb36-375"><a href="#cb36-375" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(test_rng, aes(gamlss_F, Freq_cum, color = factor(phi))) + </span></span>
<span id="cb36-376"><a href="#cb36-376" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_abline(slope = 1, color = "blue", linetype = "dashed") + </span></span>
<span id="cb36-377"><a href="#cb36-377" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point() + geom_line() +  </span></span>
<span id="cb36-378"><a href="#cb36-378" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_grid(phi ~ mu, labeller = "label_both") + </span></span>
<span id="cb36-379"><a href="#cb36-379" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal() + </span></span>
<span id="cb36-380"><a href="#cb36-380" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(x = "Theoretical cdf (gamlss.dist)", y = "Empirical cdf (my function)") + </span></span>
<span id="cb36-381"><a href="#cb36-381" aria-hidden="true" tabindex="-1"></a><span class="in">  theme(legend.position = "none") </span></span>
<span id="cb36-382"><a href="#cb36-382" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-383"><a href="#cb36-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-384"><a href="#cb36-384" aria-hidden="true" tabindex="-1"></a>Looks pretty good, no?</span>
<span id="cb36-385"><a href="#cb36-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-386"><a href="#cb36-386" aria-hidden="true" tabindex="-1"></a><span class="fu"># Using the custom distribution functions</span></span>
<span id="cb36-387"><a href="#cb36-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-388"><a href="#cb36-388" aria-hidden="true" tabindex="-1"></a>To finish out my tests of these functions, let me demonstrate their use in an actual estimation problem. I'll generate data based on a simple generalized linear model with a single predictor $X$, where the outcome $Y$ follows a double-Poisson distribution conditional on $X$. The data-generating process is:</span>
<span id="cb36-389"><a href="#cb36-389" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-390"><a href="#cb36-390" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-391"><a href="#cb36-391" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb36-392"><a href="#cb36-392" aria-hidden="true" tabindex="-1"></a>X &amp;\sim N(0, 1) <span class="sc">\\</span></span>
<span id="cb36-393"><a href="#cb36-393" aria-hidden="true" tabindex="-1"></a>Y|X &amp;\sim DPO(\mu(X), \phi) <span class="sc">\\</span></span>
<span id="cb36-394"><a href="#cb36-394" aria-hidden="true" tabindex="-1"></a>\log \mu(X) &amp;= 2 + 0.3 \times X</span>
<span id="cb36-395"><a href="#cb36-395" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb36-396"><a href="#cb36-396" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb36-397"><a href="#cb36-397" aria-hidden="true" tabindex="-1"></a>To make things interesting, I'll set the dispersion parameter to $1 / \phi = 0.6$ so that the outcome is _under_-dispersed relative to the Poisson. </span>
<span id="cb36-398"><a href="#cb36-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-399"><a href="#cb36-399" aria-hidden="true" tabindex="-1"></a>The following code generates a large sample from the data-generating process. To keep things R-centric, I use <span class="in">`gamlss.dist::rDPO`</span> to generate the outcome.</span>
<span id="cb36-400"><a href="#cb36-400" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-403"><a href="#cb36-403" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-404"><a href="#cb36-404" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">20230913</span>)</span>
<span id="cb36-405"><a href="#cb36-405" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">600</span></span>
<span id="cb36-406"><a href="#cb36-406" aria-hidden="true" tabindex="-1"></a>X <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N)</span>
<span id="cb36-407"><a href="#cb36-407" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">exp</span>(<span class="dv">2</span> <span class="sc">+</span> <span class="fl">0.3</span> <span class="sc">*</span> X)</span>
<span id="cb36-408"><a href="#cb36-408" aria-hidden="true" tabindex="-1"></a>phi_inv <span class="ot">&lt;-</span> <span class="fl">0.6</span></span>
<span id="cb36-409"><a href="#cb36-409" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">rDPO</span>(N, <span class="at">mu =</span> mu, <span class="at">sigma =</span> phi_inv)</span>
<span id="cb36-410"><a href="#cb36-410" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">X =</span> X, <span class="at">Y =</span> Y)</span>
<span id="cb36-411"><a href="#cb36-411" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-412"><a href="#cb36-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-413"><a href="#cb36-413" aria-hidden="true" tabindex="-1"></a>Here's what the sample looks like, along with a smoothed regression estimated using a basic cubic spline:</span>
<span id="cb36-414"><a href="#cb36-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-415"><a href="#cb36-415" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, fig.width = 6, fig.height = 4}</span></span>
<span id="cb36-416"><a href="#cb36-416" aria-hidden="true" tabindex="-1"></a><span class="in">ggplot(dat, aes(X, Y)) + </span></span>
<span id="cb36-417"><a href="#cb36-417" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_point(alpha = 0.1) + </span></span>
<span id="cb36-418"><a href="#cb36-418" aria-hidden="true" tabindex="-1"></a><span class="in">  geom_smooth(method = 'gam', formula = y ~ s(x, bs = "cs")) + </span></span>
<span id="cb36-419"><a href="#cb36-419" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal()</span></span>
<span id="cb36-420"><a href="#cb36-420" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-421"><a href="#cb36-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-422"><a href="#cb36-422" aria-hidden="true" tabindex="-1"></a><span class="fu">## Comparison models</span></span>
<span id="cb36-423"><a href="#cb36-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-424"><a href="#cb36-424" aria-hidden="true" tabindex="-1"></a>Before using the custom distribution, I'll fit a couple of out-of-the-box models that are useful points of comparison. </span>
<span id="cb36-425"><a href="#cb36-425" aria-hidden="true" tabindex="-1"></a>Surely the simplest, quickest, and dirtiest way to estimate such a regression is with a generalized linear model, using the "quasi-Poisson" family to allow for non-unit dispersion. In R:</span>
<span id="cb36-426"><a href="#cb36-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-429"><a href="#cb36-429" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-430"><a href="#cb36-430" aria-hidden="true" tabindex="-1"></a>quasi_fit <span class="ot">&lt;-</span> <span class="fu">glm</span>(Y <span class="sc">~</span> X, <span class="at">family =</span> <span class="fu">quasipoisson</span>(<span class="at">link =</span> <span class="st">"log"</span>), <span class="at">data =</span> dat)</span>
<span id="cb36-431"><a href="#cb36-431" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(quasi_fit)</span>
<span id="cb36-432"><a href="#cb36-432" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-433"><a href="#cb36-433" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-434"><a href="#cb36-434" aria-hidden="true" tabindex="-1"></a>This approach recovers the data-generating parameters quite well, with a dispersion estimate of <span class="in">`{r} round(summary(quasi_fit)$dispersion, 3)`</span> compared to the true dispersion parameter of <span class="in">`{r} phi_inv`</span>. </span>
<span id="cb36-435"><a href="#cb36-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-436"><a href="#cb36-436" aria-hidden="true" tabindex="-1"></a>Now let me fit the same generalized linear model but assuming that the outcome follows a true Poisson distribution (with unit dispersion). I'll fit the model in a Bayesian framework with the <span class="in">`brms`</span> package.</span>
<span id="cb36-437"><a href="#cb36-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-438"><a href="#cb36-438" aria-hidden="true" tabindex="-1"></a><span class="in">```{r Poisson, cache = TRUE}</span></span>
<span id="cb36-439"><a href="#cb36-439" aria-hidden="true" tabindex="-1"></a><span class="in">Poisson_fit &lt;- </span></span>
<span id="cb36-440"><a href="#cb36-440" aria-hidden="true" tabindex="-1"></a><span class="in">  brm(</span></span>
<span id="cb36-441"><a href="#cb36-441" aria-hidden="true" tabindex="-1"></a><span class="in">    Y ~ X, family = poisson(link = "log"),</span></span>
<span id="cb36-442"><a href="#cb36-442" aria-hidden="true" tabindex="-1"></a><span class="in">    data = dat, </span></span>
<span id="cb36-443"><a href="#cb36-443" aria-hidden="true" tabindex="-1"></a><span class="in">    warmup = 500, </span></span>
<span id="cb36-444"><a href="#cb36-444" aria-hidden="true" tabindex="-1"></a><span class="in">    iter = 1500, </span></span>
<span id="cb36-445"><a href="#cb36-445" aria-hidden="true" tabindex="-1"></a><span class="in">    chains = 4, </span></span>
<span id="cb36-446"><a href="#cb36-446" aria-hidden="true" tabindex="-1"></a><span class="in">    cores = 4,</span></span>
<span id="cb36-447"><a href="#cb36-447" aria-hidden="true" tabindex="-1"></a><span class="in">    seed = 20230913</span></span>
<span id="cb36-448"><a href="#cb36-448" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-449"><a href="#cb36-449" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-450"><a href="#cb36-450" aria-hidden="true" tabindex="-1"></a><span class="in">summary(Poisson_fit)</span></span>
<span id="cb36-451"><a href="#cb36-451" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-452"><a href="#cb36-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-453"><a href="#cb36-453" aria-hidden="true" tabindex="-1"></a>This specification recovers the intercept and slope parameters well too, but doesn't provide any estimate of dispersion. </span>
<span id="cb36-454"><a href="#cb36-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-455"><a href="#cb36-455" aria-hidden="true" tabindex="-1"></a>As an alternative, I'll also fit the model using the negative binomial distribution, which is a generalization of the Poisson that allows for over-dispersion (but not under-dispersion):</span>
<span id="cb36-456"><a href="#cb36-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-457"><a href="#cb36-457" aria-hidden="true" tabindex="-1"></a><span class="in">```{r negbin, cache = TRUE}</span></span>
<span id="cb36-458"><a href="#cb36-458" aria-hidden="true" tabindex="-1"></a><span class="in">negbin_fit &lt;- </span></span>
<span id="cb36-459"><a href="#cb36-459" aria-hidden="true" tabindex="-1"></a><span class="in">  brm(</span></span>
<span id="cb36-460"><a href="#cb36-460" aria-hidden="true" tabindex="-1"></a><span class="in">    Y ~ X, family = negbinomial(link = "log"),</span></span>
<span id="cb36-461"><a href="#cb36-461" aria-hidden="true" tabindex="-1"></a><span class="in">    data = dat, </span></span>
<span id="cb36-462"><a href="#cb36-462" aria-hidden="true" tabindex="-1"></a><span class="in">    warmup = 500, </span></span>
<span id="cb36-463"><a href="#cb36-463" aria-hidden="true" tabindex="-1"></a><span class="in">    iter = 1500, </span></span>
<span id="cb36-464"><a href="#cb36-464" aria-hidden="true" tabindex="-1"></a><span class="in">    chains = 4, </span></span>
<span id="cb36-465"><a href="#cb36-465" aria-hidden="true" tabindex="-1"></a><span class="in">    cores = 4,</span></span>
<span id="cb36-466"><a href="#cb36-466" aria-hidden="true" tabindex="-1"></a><span class="in">    seed = 20230913</span></span>
<span id="cb36-467"><a href="#cb36-467" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-468"><a href="#cb36-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-469"><a href="#cb36-469" aria-hidden="true" tabindex="-1"></a><span class="in">summary(negbin_fit)</span></span>
<span id="cb36-470"><a href="#cb36-470" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-471"><a href="#cb36-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-472"><a href="#cb36-472" aria-hidden="true" tabindex="-1"></a>The <span class="in">`brms`</span> package implements the negative binomial using the rate parameterization, so the <span class="in">`shape`</span> parameter corresponds to the inverse dispersion. Thus, a large shape parameter (as in the above fit) implies dispersion that is very close to one (i.e., close to the Poisson).</span>
<span id="cb36-473"><a href="#cb36-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-474"><a href="#cb36-474" aria-hidden="true" tabindex="-1"></a><span class="fu">## Double-Poisson model</span></span>
<span id="cb36-475"><a href="#cb36-475" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-476"><a href="#cb36-476" aria-hidden="true" tabindex="-1"></a>Now I'll fit the same model as previously but using my custom-built double-Poisson distribution. Following <span class="co">[</span><span class="ot">Paul Buerkner's vignette</span><span class="co">](https://cran.r-project.org/web/packages/brms/vignettes/brms_customfamilies.html)</span> on using custom distributions in <span class="in">`brms`</span>, I'll first specify the custom family object for the double-Poisson:</span>
<span id="cb36-477"><a href="#cb36-477" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-480"><a href="#cb36-480" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-481"><a href="#cb36-481" aria-hidden="true" tabindex="-1"></a>double_Poisson <span class="ot">&lt;-</span> <span class="fu">custom_family</span>(</span>
<span id="cb36-482"><a href="#cb36-482" aria-hidden="true" tabindex="-1"></a>  <span class="st">"dpo"</span>, <span class="at">dpars =</span> <span class="fu">c</span>(<span class="st">"mu"</span>,<span class="st">"phi"</span>),</span>
<span id="cb36-483"><a href="#cb36-483" aria-hidden="true" tabindex="-1"></a>  <span class="at">links =</span> <span class="fu">c</span>(<span class="st">"log"</span>,<span class="st">"log"</span>),</span>
<span id="cb36-484"><a href="#cb36-484" aria-hidden="true" tabindex="-1"></a>  <span class="at">lb =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="at">ub =</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="cn">NA</span>),</span>
<span id="cb36-485"><a href="#cb36-485" aria-hidden="true" tabindex="-1"></a>  <span class="at">type =</span> <span class="st">"int"</span></span>
<span id="cb36-486"><a href="#cb36-486" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb36-487"><a href="#cb36-487" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-488"><a href="#cb36-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-489"><a href="#cb36-489" aria-hidden="true" tabindex="-1"></a>I set the defaults to use a log-link for the mean (just as with the Poisson and negative binomial families) and a log-link for the inverse-dispersion. </span>
<span id="cb36-490"><a href="#cb36-490" aria-hidden="true" tabindex="-1"></a>Next, I'll create an object to add the custom stan code from above into the code created by <span class="in">`brm`</span> for fitting the model:</span>
<span id="cb36-493"><a href="#cb36-493" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-494"><a href="#cb36-494" aria-hidden="true" tabindex="-1"></a>double_Poisson_stanvars <span class="ot">&lt;-</span> <span class="fu">stanvar</span>(<span class="at">scode =</span> stancode_qr, <span class="at">block =</span> <span class="st">"functions"</span>)</span>
<span id="cb36-495"><a href="#cb36-495" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-496"><a href="#cb36-496" aria-hidden="true" tabindex="-1"></a>I'll also need to specify a prior to use for the $\phi$ parameter of the double-Poisson distribution:</span>
<span id="cb36-499"><a href="#cb36-499" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb36-500"><a href="#cb36-500" aria-hidden="true" tabindex="-1"></a>phi_prior <span class="ot">&lt;-</span> <span class="fu">prior</span>(<span class="fu">exponential</span>(<span class="dv">1</span>), <span class="at">class =</span> <span class="st">"phi"</span>)</span>
<span id="cb36-501"><a href="#cb36-501" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-502"><a href="#cb36-502" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-503"><a href="#cb36-503" aria-hidden="true" tabindex="-1"></a>Now I'm ready to fit the model:</span>
<span id="cb36-504"><a href="#cb36-504" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-505"><a href="#cb36-505" aria-hidden="true" tabindex="-1"></a><span class="in">```{r DPO, cache = TRUE}</span></span>
<span id="cb36-506"><a href="#cb36-506" aria-hidden="true" tabindex="-1"></a><span class="in">DPO_fit &lt;- </span></span>
<span id="cb36-507"><a href="#cb36-507" aria-hidden="true" tabindex="-1"></a><span class="in">  brm(</span></span>
<span id="cb36-508"><a href="#cb36-508" aria-hidden="true" tabindex="-1"></a><span class="in">    Y ~ X, family = double_Poisson,</span></span>
<span id="cb36-509"><a href="#cb36-509" aria-hidden="true" tabindex="-1"></a><span class="in">    prior = phi_prior,</span></span>
<span id="cb36-510"><a href="#cb36-510" aria-hidden="true" tabindex="-1"></a><span class="in">    stanvars = double_Poisson_stanvars,</span></span>
<span id="cb36-511"><a href="#cb36-511" aria-hidden="true" tabindex="-1"></a><span class="in">    data = dat, </span></span>
<span id="cb36-512"><a href="#cb36-512" aria-hidden="true" tabindex="-1"></a><span class="in">    warmup = 500, </span></span>
<span id="cb36-513"><a href="#cb36-513" aria-hidden="true" tabindex="-1"></a><span class="in">    iter = 1500, </span></span>
<span id="cb36-514"><a href="#cb36-514" aria-hidden="true" tabindex="-1"></a><span class="in">    chains = 4, </span></span>
<span id="cb36-515"><a href="#cb36-515" aria-hidden="true" tabindex="-1"></a><span class="in">    cores = 4,</span></span>
<span id="cb36-516"><a href="#cb36-516" aria-hidden="true" tabindex="-1"></a><span class="in">    seed = 20230913</span></span>
<span id="cb36-517"><a href="#cb36-517" aria-hidden="true" tabindex="-1"></a><span class="in">  )</span></span>
<span id="cb36-518"><a href="#cb36-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-519"><a href="#cb36-519" aria-hidden="true" tabindex="-1"></a><span class="in">summary(DPO_fit)</span></span>
<span id="cb36-520"><a href="#cb36-520" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-521"><a href="#cb36-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-522"><a href="#cb36-522" aria-hidden="true" tabindex="-1"></a>The regression coefficient estimates are basically identical to those from the Poisson and negative-binomial models, estimated with slightly better precision than with the Poisson or negative binomial families. However, we get a posterior for $\phi$ that corresponds to _under_-dispersion. Here's the posterior for the dispersion (i.e., $1 / \phi$):</span>
<span id="cb36-523"><a href="#cb36-523" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-524"><a href="#cb36-524" aria-hidden="true" tabindex="-1"></a><span class="in">```{r DPO-dispersion, fig.width = 5, fig.height = 2}</span></span>
<span id="cb36-525"><a href="#cb36-525" aria-hidden="true" tabindex="-1"></a><span class="in">mcmc_areas(DPO_fit, pars = "phi", transformations = \(x) 1 / x) + </span></span>
<span id="cb36-526"><a href="#cb36-526" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal()</span></span>
<span id="cb36-527"><a href="#cb36-527" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-528"><a href="#cb36-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-529"><a href="#cb36-529" aria-hidden="true" tabindex="-1"></a><span class="fu">## Model comparison</span></span>
<span id="cb36-530"><a href="#cb36-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-531"><a href="#cb36-531" aria-hidden="true" tabindex="-1"></a>I'd like to get a sense of how much better the double-Poisson model does with capturing the real data-generating process compared to the simple Poisson model or the negative binomial model. There's a wide range of diagnostics that can inform such comparisons. I'll consider the leave-one-out information criteria (LOOIC) and also look at some posterior predictive checks.</span>
<span id="cb36-532"><a href="#cb36-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-533"><a href="#cb36-533" aria-hidden="true" tabindex="-1"></a>To calculate LOOIC for the double-Poisson model, I first need to provide a <span class="in">`log_lik`</span> function that <span class="in">`brms`</span> can use<span class="ot">[^loglik-in-R]</span>. Here's code, using the Stan function from above:</span>
<span id="cb36-534"><a href="#cb36-534" aria-hidden="true" tabindex="-1"></a><span class="in">```{r DPO-loglik, cache = TRUE}</span></span>
<span id="cb36-535"><a href="#cb36-535" aria-hidden="true" tabindex="-1"></a><span class="in">expose_functions(DPO_fit, vectorize = TRUE)</span></span>
<span id="cb36-536"><a href="#cb36-536" aria-hidden="true" tabindex="-1"></a><span class="in">log_lik_dpo &lt;- function(i, prep) {</span></span>
<span id="cb36-537"><a href="#cb36-537" aria-hidden="true" tabindex="-1"></a><span class="in">  mu &lt;- brms::get_dpar(prep, "mu", i = i)</span></span>
<span id="cb36-538"><a href="#cb36-538" aria-hidden="true" tabindex="-1"></a><span class="in">  phi &lt;- brms::get_dpar(prep, "phi", i = i)</span></span>
<span id="cb36-539"><a href="#cb36-539" aria-hidden="true" tabindex="-1"></a><span class="in">  y &lt;- prep$data$Y[i]</span></span>
<span id="cb36-540"><a href="#cb36-540" aria-hidden="true" tabindex="-1"></a><span class="in">  dpo_lpmf(y, mu, phi)</span></span>
<span id="cb36-541"><a href="#cb36-541" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-542"><a href="#cb36-542" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-543"><a href="#cb36-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-544"><a href="#cb36-544" aria-hidden="true" tabindex="-1"></a><span class="ot">[^loglik-in-R]: </span>Rather than exposing and calling the Stan function, one could just re-implement the log likelihood in R. (Probably the easier way in practice, but again I'm trying to learn me some Stan here...)</span>
<span id="cb36-545"><a href="#cb36-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-546"><a href="#cb36-546" aria-hidden="true" tabindex="-1"></a>I can then compute LOOIC for all three models:</span>
<span id="cb36-547"><a href="#cb36-547" aria-hidden="true" tabindex="-1"></a><span class="in">```{r loo, cache = TRUE}</span></span>
<span id="cb36-548"><a href="#cb36-548" aria-hidden="true" tabindex="-1"></a><span class="in">loo(DPO_fit, Poisson_fit, negbin_fit)</span></span>
<span id="cb36-549"><a href="#cb36-549" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-550"><a href="#cb36-550" aria-hidden="true" tabindex="-1"></a>By these measures, the double-Poisson model has substantially better fit than either of the other models. </span>
<span id="cb36-551"><a href="#cb36-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-552"><a href="#cb36-552" aria-hidden="true" tabindex="-1"></a>To do posterior predictive checks, I need to provide a <span class="in">`posterior_predict`</span> function that <span class="in">`brms`</span> can use. I'll again do an implementation that uses my custom <span class="in">`dpo_rng()`</span> from Stan.<span class="ot">[^PP-in-R]</span></span>
<span id="cb36-553"><a href="#cb36-553" aria-hidden="true" tabindex="-1"></a><span class="in">```{r posterior-predictor-dpo}</span></span>
<span id="cb36-554"><a href="#cb36-554" aria-hidden="true" tabindex="-1"></a><span class="in">posterior_predict_dpo &lt;- function(i, prep, maxval = NULL, ...) {</span></span>
<span id="cb36-555"><a href="#cb36-555" aria-hidden="true" tabindex="-1"></a><span class="in">  mu &lt;- brms::get_dpar(prep, "mu", i = i)</span></span>
<span id="cb36-556"><a href="#cb36-556" aria-hidden="true" tabindex="-1"></a><span class="in">  phi &lt;- brms::get_dpar(prep, "phi", i = i)</span></span>
<span id="cb36-557"><a href="#cb36-557" aria-hidden="true" tabindex="-1"></a><span class="in">  if (is.null(maxval)) maxval &lt;- 20 * mu / min(phi, 1)</span></span>
<span id="cb36-558"><a href="#cb36-558" aria-hidden="true" tabindex="-1"></a><span class="in">  dpo_rng(mu, phi, maxval = maxval)</span></span>
<span id="cb36-559"><a href="#cb36-559" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-560"><a href="#cb36-560" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-561"><a href="#cb36-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-562"><a href="#cb36-562" aria-hidden="true" tabindex="-1"></a><span class="ot">[^PP-in-R]: </span>Of course, I could have saved a bunch of trouble by just using <span class="in">`gamlss.dist::rDPO()`</span> instead.</span>
<span id="cb36-563"><a href="#cb36-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-564"><a href="#cb36-564" aria-hidden="true" tabindex="-1"></a>Functions in hand, I can now compute posterior predictions for the double-Poisson model and make pretty pictures of them, along with corresponding plots for the Poisson and negative-binomial models.</span>
<span id="cb36-565"><a href="#cb36-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-566"><a href="#cb36-566" aria-hidden="true" tabindex="-1"></a><span class="in">```{r ppd, fig.width = 8, fig.height = 6}</span></span>
<span id="cb36-567"><a href="#cb36-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-568"><a href="#cb36-568" aria-hidden="true" tabindex="-1"></a><span class="in">Yrep_Poisson &lt;- posterior_predict(Poisson_fit, draws = 400) </span></span>
<span id="cb36-569"><a href="#cb36-569" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("blue")</span></span>
<span id="cb36-570"><a href="#cb36-570" aria-hidden="true" tabindex="-1"></a><span class="in">Poisson_root &lt;- ppc_rootogram(dat$Y, Yrep_Poisson, style = "hanging") + labs(title = "Poisson")</span></span>
<span id="cb36-571"><a href="#cb36-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-572"><a href="#cb36-572" aria-hidden="true" tabindex="-1"></a><span class="in">Yrep_negbin &lt;- posterior_predict(negbin_fit, draws = 400)</span></span>
<span id="cb36-573"><a href="#cb36-573" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("green")</span></span>
<span id="cb36-574"><a href="#cb36-574" aria-hidden="true" tabindex="-1"></a><span class="in">negbin_root &lt;- ppc_rootogram(dat$Y, Yrep_negbin, style = "hanging") + labs(title = "Negative-binomial")</span></span>
<span id="cb36-575"><a href="#cb36-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-576"><a href="#cb36-576" aria-hidden="true" tabindex="-1"></a><span class="in">Yrep_dpo &lt;- posterior_predict(DPO_fit, draws = 400)</span></span>
<span id="cb36-577"><a href="#cb36-577" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("purple")</span></span>
<span id="cb36-578"><a href="#cb36-578" aria-hidden="true" tabindex="-1"></a><span class="in">dpo_root &lt;- ppc_rootogram(dat$Y, Yrep_dpo, style = "hanging") + labs(title = "Double-Poisson")</span></span>
<span id="cb36-579"><a href="#cb36-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-580"><a href="#cb36-580" aria-hidden="true" tabindex="-1"></a><span class="in">dpo_root / Poisson_root / negbin_root &amp;</span></span>
<span id="cb36-581"><a href="#cb36-581" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal()</span></span>
<span id="cb36-582"><a href="#cb36-582" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-583"><a href="#cb36-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-584"><a href="#cb36-584" aria-hidden="true" tabindex="-1"></a>The differences in predicted frequencies are not that obvious from these plots. The main notable difference is that the Poisson and negative-binomial distributions predict more small counts (in the range of 0 to 3) than are observed, whereas the double-Poisson does better at matching the observed frequency in this range.</span>
<span id="cb36-585"><a href="#cb36-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-586"><a href="#cb36-586" aria-hidden="true" tabindex="-1"></a>I think the lack of glaring differences in the above plots happens because I'm just looking at the marginal distribution of the outcome, and the (explained) variation due to the predictor dampens the degree of under-dispersion. To see this, I'll create some plots that are grouped by quintiles of $X$:</span>
<span id="cb36-587"><a href="#cb36-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-588"><a href="#cb36-588" aria-hidden="true" tabindex="-1"></a><span class="in">```{r ppd-grouped, fig.width = 12, fig.height = 9}</span></span>
<span id="cb36-589"><a href="#cb36-589" aria-hidden="true" tabindex="-1"></a><span class="in">dat$g &lt;- cut(dat$X, breaks = quantile(dat$X, seq(0,1,0.2)), include.lowest = TRUE)</span></span>
<span id="cb36-590"><a href="#cb36-590" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-591"><a href="#cb36-591" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("blue")</span></span>
<span id="cb36-592"><a href="#cb36-592" aria-hidden="true" tabindex="-1"></a><span class="in">Poisson_bars &lt;- ppc_bars_grouped(</span></span>
<span id="cb36-593"><a href="#cb36-593" aria-hidden="true" tabindex="-1"></a><span class="in">  dat$Y, Yrep_Poisson, dat$g, </span></span>
<span id="cb36-594"><a href="#cb36-594" aria-hidden="true" tabindex="-1"></a><span class="in">  prob = 0.5, </span></span>
<span id="cb36-595"><a href="#cb36-595" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_args = list(ncol = 5)</span></span>
<span id="cb36-596"><a href="#cb36-596" aria-hidden="true" tabindex="-1"></a><span class="in">) + </span></span>
<span id="cb36-597"><a href="#cb36-597" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(title = "Poisson")</span></span>
<span id="cb36-598"><a href="#cb36-598" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-599"><a href="#cb36-599" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("green")</span></span>
<span id="cb36-600"><a href="#cb36-600" aria-hidden="true" tabindex="-1"></a><span class="in">negbin_bars &lt;- ppc_bars_grouped(</span></span>
<span id="cb36-601"><a href="#cb36-601" aria-hidden="true" tabindex="-1"></a><span class="in">  dat$Y, Yrep_negbin, dat$g, </span></span>
<span id="cb36-602"><a href="#cb36-602" aria-hidden="true" tabindex="-1"></a><span class="in">  prob = 0.5, </span></span>
<span id="cb36-603"><a href="#cb36-603" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_args = list(ncol = 5)</span></span>
<span id="cb36-604"><a href="#cb36-604" aria-hidden="true" tabindex="-1"></a><span class="in">) + </span></span>
<span id="cb36-605"><a href="#cb36-605" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(title = "Negative-binomial")</span></span>
<span id="cb36-606"><a href="#cb36-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-607"><a href="#cb36-607" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("purple")</span></span>
<span id="cb36-608"><a href="#cb36-608" aria-hidden="true" tabindex="-1"></a><span class="in">dpo_bars &lt;- ppc_bars_grouped(</span></span>
<span id="cb36-609"><a href="#cb36-609" aria-hidden="true" tabindex="-1"></a><span class="in">  dat$Y, Yrep_dpo, dat$g, </span></span>
<span id="cb36-610"><a href="#cb36-610" aria-hidden="true" tabindex="-1"></a><span class="in">  prob = 0.5, </span></span>
<span id="cb36-611"><a href="#cb36-611" aria-hidden="true" tabindex="-1"></a><span class="in">  facet_args = list(ncol = 5)</span></span>
<span id="cb36-612"><a href="#cb36-612" aria-hidden="true" tabindex="-1"></a><span class="in">) + </span></span>
<span id="cb36-613"><a href="#cb36-613" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(title = "Double-Poisson")</span></span>
<span id="cb36-614"><a href="#cb36-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-615"><a href="#cb36-615" aria-hidden="true" tabindex="-1"></a><span class="in">dpo_bars / Poisson_bars / negbin_bars &amp;</span></span>
<span id="cb36-616"><a href="#cb36-616" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal()</span></span>
<span id="cb36-617"><a href="#cb36-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-618"><a href="#cb36-618" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-619"><a href="#cb36-619" aria-hidden="true" tabindex="-1"></a>Still kind of subtle, I suppose, but you can see more clearly that the double-Poisson does a better job than the other distributions at matching the modes (peaks) of the empirical distribution in each of these subgroups.</span>
<span id="cb36-620"><a href="#cb36-620" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-621"><a href="#cb36-621" aria-hidden="true" tabindex="-1"></a>One last approach is to look directly at the degree of dispersion in the posterior predictive distributions relative to the actual data. I'll calculate this dispersion by re-fitting the quick-and-dirty quasi-poisson model in each sample:</span>
<span id="cb36-622"><a href="#cb36-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-623"><a href="#cb36-623" aria-hidden="true" tabindex="-1"></a><span class="in">```{r ppc-dispersion, cache = TRUE, fig.width = 8, fig.height = 5}</span></span>
<span id="cb36-624"><a href="#cb36-624" aria-hidden="true" tabindex="-1"></a><span class="in">dispersion_coef &lt;- function(y) {</span></span>
<span id="cb36-625"><a href="#cb36-625" aria-hidden="true" tabindex="-1"></a><span class="in">  quasi_fit &lt;- glm(y ~ dat$X, family = quasipoisson(link = "log"))</span></span>
<span id="cb36-626"><a href="#cb36-626" aria-hidden="true" tabindex="-1"></a><span class="in">  sum(residuals(quasi_fit, type = "pearson")^2) / quasi_fit$df.residual</span></span>
<span id="cb36-627"><a href="#cb36-627" aria-hidden="true" tabindex="-1"></a><span class="in">}</span></span>
<span id="cb36-628"><a href="#cb36-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-629"><a href="#cb36-629" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("blue")</span></span>
<span id="cb36-630"><a href="#cb36-630" aria-hidden="true" tabindex="-1"></a><span class="in">Poisson_disp &lt;- ppc_stat(dat$Y, Yrep_Poisson, stat = dispersion_coef, binwidth = 0.02) + </span></span>
<span id="cb36-631"><a href="#cb36-631" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(title = "Poisson")</span></span>
<span id="cb36-632"><a href="#cb36-632" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-633"><a href="#cb36-633" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("green")</span></span>
<span id="cb36-634"><a href="#cb36-634" aria-hidden="true" tabindex="-1"></a><span class="in">negbin_disp &lt;- ppc_stat(dat$Y, Yrep_negbin, stat = dispersion_coef, binwidth = 0.02) + </span></span>
<span id="cb36-635"><a href="#cb36-635" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(title = "Negative-binomial")</span></span>
<span id="cb36-636"><a href="#cb36-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-637"><a href="#cb36-637" aria-hidden="true" tabindex="-1"></a><span class="in">color_scheme_set("purple")</span></span>
<span id="cb36-638"><a href="#cb36-638" aria-hidden="true" tabindex="-1"></a><span class="in">dpo_disp &lt;- ppc_stat(dat$Y, Yrep_dpo, stat = dispersion_coef, binwidth = 0.02) + </span></span>
<span id="cb36-639"><a href="#cb36-639" aria-hidden="true" tabindex="-1"></a><span class="in">  labs(title = "Double-Poisson")</span></span>
<span id="cb36-640"><a href="#cb36-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-641"><a href="#cb36-641" aria-hidden="true" tabindex="-1"></a><span class="in">dpo_disp / Poisson_disp / negbin_disp &amp;</span></span>
<span id="cb36-642"><a href="#cb36-642" aria-hidden="true" tabindex="-1"></a><span class="in">  theme_minimal() &amp; </span></span>
<span id="cb36-643"><a href="#cb36-643" aria-hidden="true" tabindex="-1"></a><span class="in">  xlim(c(0.45, 1.3))</span></span>
<span id="cb36-644"><a href="#cb36-644" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-645"><a href="#cb36-645" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-646"><a href="#cb36-646" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-647"><a href="#cb36-647" aria-hidden="true" tabindex="-1"></a>From this, we can clearly see that the Poisson and negative binomial model generate data with approximately unit dispersion, which doesn't match at all with the degree of dispersion in the observed data. </span>
<span id="cb36-648"><a href="#cb36-648" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-649"><a href="#cb36-649" aria-hidden="true" tabindex="-1"></a><span class="fu"># Kudos</span></span>
<span id="cb36-650"><a href="#cb36-650" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-651"><a href="#cb36-651" aria-hidden="true" tabindex="-1"></a>So there you have it. It's really quite feasible to build models with custom distributions. Efron (1986) also describes a double-binomial distribution (as an approximation to the "quasi-binomial" family of generalized linear models), which you could play with implementing for yourself, dear reader, if you are in the mood. </span>
<span id="cb36-652"><a href="#cb36-652" aria-hidden="true" tabindex="-1"></a>Major kudos to <span class="co">[</span><span class="ot">Paul Buerkner</span><span class="co">](https://paul-buerkner.github.io/)</span> for <span class="co">[</span><span class="ot">`brms`</span><span class="co">](https://paul-buerkner.github.io/brms/)</span>, <span class="co">[</span><span class="ot">Jonah Gabry</span><span class="co">](https://jgabry.github.io/)</span> and collaborators for <span class="co">[</span><span class="ot">`bayesplot`</span><span class="co">](https://mc-stan.org/bayesplot/)</span>, and <span class="co">[</span><span class="ot">the incredible team of folks</span><span class="co">](https://mc-stan.org/about/team/)</span> developing <span class="co">[</span><span class="ot">`Stan`</span><span class="co">](https://mc-stan.org/)</span>.</span>
<span id="cb36-653"><a href="#cb36-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-654"><a href="#cb36-654" aria-hidden="true" tabindex="-1"></a><span class="fu"># Colophon</span></span>
<span id="cb36-655"><a href="#cb36-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-656"><a href="#cb36-656" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, include = FALSE, warning = FALSE}</span></span>
<span id="cb36-657"><a href="#cb36-657" aria-hidden="true" tabindex="-1"></a><span class="in">file.remove("DPO-lpmf.stan")</span></span>
<span id="cb36-658"><a href="#cb36-658" aria-hidden="true" tabindex="-1"></a><span class="in">file.remove("DPO-cdf.stan")</span></span>
<span id="cb36-659"><a href="#cb36-659" aria-hidden="true" tabindex="-1"></a><span class="in">file.remove("DPO-quantile.stan")</span></span>
<span id="cb36-660"><a href="#cb36-660" aria-hidden="true" tabindex="-1"></a><span class="in">file.remove("DPO-rng.stan")</span></span>
<span id="cb36-661"><a href="#cb36-661" aria-hidden="true" tabindex="-1"></a><span class="in">file.remove("DPO-fit.stan")</span></span>
<span id="cb36-662"><a href="#cb36-662" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-663"><a href="#cb36-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-664"><a href="#cb36-664" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, echo = FALSE}</span></span>
<span id="cb36-665"><a href="#cb36-665" aria-hidden="true" tabindex="-1"></a><span class="in">sessionInfo()</span></span>
<span id="cb36-666"><a href="#cb36-666" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb36-667"><a href="#cb36-667" aria-hidden="true" tabindex="-1"></a></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>