---
title: Variance stabilization of Cohen's d
date: '2025-07-14'
categories:
- effect-size
- standardized-mean-difference
- delta-method
execute:
  code-fold: true
  message: false
  warning: false
code-tools: true
bibliography: d-r-z-refs.bib
draft: true
---

In a recent _Psychological Methods_ paper, @Haaf2023does suggest conducting meta-analysis of standardized mean differences after transforming them to point biserial correlations and then applying Fisher's $z$-transformation. 
They argue that this leads to a variance-stabilized effect size, which has sampling variance that is constant across varying values of the true parameter $\delta$. 
@Bartos2023robust cites @Haaf2023does as justification for conducting meta-analysis of standardized mean differences after applying this $d$-to-$r$-to-$z$ transformation.
All this surprised me a bit because the transformation was unfamiliar, although I've written about these sorts of effect size conversions before [cf. @Pustejovsky2014converting].
In other work [@Pustejovsky2018testing], I've used the variance-stabilizing transformation given in @Hedges1985statistical, which is different than this approach. 
What gives? Is this $d$-to-$r$-to-$z$ business _really_ variance stabilizing?

The first step in the transformation proposed by @Haaf2023does depends on the relative sample sizes of the two groups, which I will parameterize as $R = N_1 : N_2$.
Letting $a = (R + 1)^2 / R$, the transformation function is given by 
$$
z(d; a) = \frac{1}{2}\left[\log\left(\sqrt{d^2 + a} + d\right) - \log\left(\sqrt{d^2 + a} - d\right)\right]
$$

The shape of the transformation is depicted in @fig-Haaf-transform.

```{r}
#| label: fig-Haaf-transform
#| fig-width: 8
#| fig-height: 4
#| fig-cap: "d-to-r-to-z transformation for various allocation fractions $p$. The dashed line is y = x / 2."

library(tidyverse)

d_to_z <- function(d, R) {
  r <- d / sqrt(d^2 + (R + 1)^2 / R)
  atanh(r)
}

d_to_h <- function(d, R) {
  a <- (R + 1)^2 / R
  sqrt(2) * sign(d) * (log(abs(d) + sqrt(d^2 + 2 * a)) - log(2 * a) / 2)
}

transform_dat <- 
  expand_grid(
    d = seq(-5,5,0.02),
    R = 1:3
  ) |>
  mutate(
    z = d_to_z(d, R),
    h = d_to_h(d, R),
    R_fac = factor(paste(R,"1", sep = ":")) |> fct_rev()
  )

ggplot(transform_dat) +
  aes(d, z, color = R_fac) + 
  geom_abline(slope = 1 / 2, intercept = 0, linetype = "dashed") + 
  geom_line() + 
  theme_minimal() + 
  labs(color = "R") + 
  scale_x_continuous(breaks = seq(-5,5,1), minor_breaks = NULL)
```

The variance-stabilizing transformation given in @Hedges1985statistical is 
$$
h(d; a) = \sqrt{2} \left(\frac{d}{|d|}\right) \left[\log\left(|d| + \sqrt{d^2 + 2a}\right) - \frac{1}{2}\log\left(2a\right)\right]
$$

@fig-transformation-comparison compares the two transformation functions, with $h(z)$ in red and $z(d)$ in blue. The functions are very similar over the range [-2, 2] and only begin to diverge when $|d| > 3$, the realm of what would typically be considered implausibly large effect sizes.

```{r}
#| label: fig-transformation-comparison
#| fig-width: 8
#| fig-height: 3
#| fig-cap: "Comparison of transformation functions given by Haaf and Rouder (2023) and by Hedges and Olkin (1985)"

transform_dat |>
  mutate(R_fac = fct_rev(R_fac) |> fct_relabel(\(x) paste("R ==", x))) |>
  pivot_longer(cols = c(z, h), names_to = "stat", values_to = "val") |>
  ggplot() + 
  aes(d, val, color = stat) + 
  geom_line() + 
  facet_wrap(~ R_fac, labeller = "label_parsed") + 
  theme_minimal() + 
  theme(legend.position = c(0.05, 0.9)) + 
  scale_x_continuous(breaks = seq(-4,4,2)) + 
  labs(y = "", color = "")
```
This suggests that any differences in the performance of the transformations will be driven by behavior in the extremes of the distribution and will likely be less pronounced when $N_1$ and $N_2$ are large.
I ran some quick simulations to look at how the variance of $d$, $z(d)$, and $h(d)$ change as a function of the true average effect size $\delta$.

```{r}
#| cache: true

library(simhelpers)
library(future)
plan(multisession)

r_smd <- function(reps, delta = 0, N = 20, R = 1) {
  a <- sqrt(N * R / (R + 1)^2)
  ncp <- delta * a
  tstats <- rt(reps, df = N - 2, ncp = ncp)
  d <- tstats / a
  z <- d_to_z(d, R = R)
  h <- d_to_h(d, R = R)
  data.frame(d = d, z = z, h = h)
}

calc_M_SE <- function(dat) {
  M <- colMeans(dat, na.rm = TRUE)
  SE <- apply(dat, 2, sd, na.rm = TRUE)
  data.frame(stat = names(dat), M = M, SE = SE)
}

sim_d_twosample <- compose(calc_M_SE, r_smd)

sim_grid <-
  expand_grid(
    N = c(10, 30, 50),
    R = 1:3,
    delta = seq(0, 3, 0.1)
  ) |>
  mutate(
    reps = 2e4
  )

d_twosample_res <- 
  sim_grid |>
  evaluate_by_row(
    sim_d_twosample, 
    system_time = FALSE,
    verbose = FALSE
  ) |>
  mutate(
    R_fac = factor(R) |> fct_relabel(\(x) paste0("R == ", x, ":1")),
    N_fac = factor(N) |> fct_relabel(\(x) paste("N ==", x)),
    SE_scaled = if_else(stat == "d", SE * sqrt((N - 2) * R / (R + 1)^2), sqrt(N - 2) * SE)
  )

```

@fig-true-SE-twosample

```{r}
#| label: fig-true-SE-twosample
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "True standard errors of untransformed $d$ and transformed ($z(d)$ and $h(d)$) effect size estimates under a two-sample homoskedastic normal model. Standard errors are rescaled so that SE = 1 when $\\delta$ = 0."

ggplot(d_twosample_res) + 
  aes(delta, SE_scaled, color = stat) + 
  geom_hline(yintercept = 0) + 
  geom_line() + 
  facet_grid(N_fac ~ R_fac, scales = "free_y", labeller = "label_parsed") + 
  theme_minimal() +
  labs(
    x = expression(delta), 
    y = "True Standard Error (rescaled)", 
    color = ""
  )
```

```{r}
#| cache: true

r_bivariate <- function(
  reps, delta = 0, N = 20, R = 1, fixed = TRUE
) {
  require(mvtnorm)
  rho <- delta / sqrt(delta^2 + (R + 1)^2 / R)
  Sigma <- rho + diag(1 - rho, nrow = 2L)
  d <- replicate(reps, {
    Z <- rmvnorm(n = N, mean = c(0,0), sigma = Sigma)
    
    if (fixed) {
      X <- ifelse(Z[,1] <= qnorm(R / (R + 1)), "A","B")
      Xtb <- table(X)
      if (any(Xtb == 0)) return(NA_real_)
    } else {
      X <- ifelse(rank(Z[,1]) <= N * R / (R + 1), "A","B")
      Xtb <- table(X)
      R <- Xtb[1] / Xtb[2]
    }
    
    M <- tapply(Z[,2], X, mean)
    V <- tapply(Z[,2], X, var)
    Vpool <- sum((Xtb - 1) * V) / (N - 2)
    as.numeric(diff(M)) / sqrt(Vpool)
  }, simplify = FALSE) |>
    unlist()
  z <- d_to_z(d, R = R)
  h <- d_to_h(d, R = R)
  data.frame(d = d, z = z, h = h)
}

sim_bivariate <- compose(calc_M_SE, r_bivariate)

d_bivariate <- 
  sim_grid |>
  mutate(reps = 2e2) |> 
  cross_join(tibble(fixed = c(TRUE, FALSE))) |> 
  evaluate_by_row(
    sim_bivariate,
    system_time = FALSE,
    verbose = FALSE
  ) |>
  mutate(
    R_fac = factor(R) |> fct_relabel(\(x) paste0("R == ", x, ":1")),
    N_fac = factor(N) |> fct_relabel(\(x) paste("N ==", x)),
    SE_scaled = if_else(stat == "d", SE * sqrt((N - 2) * R / (R + 1)^2), sqrt(N - 2) * SE)
  )

```

```{r}
#| label: fig-true-SE-bivariate-fixed
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "True standard errors of untransformed $d$ and transformed ($z(d)$ and $h(d)$) effect size estimates under a dichotomized bivariate normal model with a fixed threshold. Standard errors are rescaled so that SE = 1 when $\\delta$ = 0."

d_bivariate |>
  filter(fixed) |>
ggplot() + 
  aes(delta, SE_scaled, color = stat) + 
  geom_hline(yintercept = 0) + 
  geom_line() + 
  facet_grid(N_fac ~ R_fac, scales = "free_y", labeller = "label_parsed") + 
  theme_minimal() +
  labs(
    x = expression(delta), 
    y = "True Standard Error (rescaled)", 
    color = ""
  )
```

```{r}
#| label: fig-true-SE-bivariate-sampled
#| fig-width: 8
#| fig-height: 6
#| fig-cap: "True standard errors of untransformed $d$ and transformed ($z(d)$ and $h(d)$) effect size estimates under a dichotomized bivariate normal model with a sample threshold. Standard errors are rescaled so that SE = 1 when $\\delta$ = 0."

d_bivariate |>
  filter(!fixed) |>
ggplot() + 
  aes(delta, SE_scaled, color = stat) + 
  geom_hline(yintercept = 0) + 
  geom_line() + 
  facet_grid(N_fac ~ R_fac, scales = "free_y", labeller = "label_parsed") + 
  theme_minimal() +
  labs(
    x = expression(delta), 
    y = "True Standard Error (rescaled)", 
    color = ""
  )
```
